/*
===========================================================================
Copyright (C) 2015 the OpenMoHAA team

This file is part of OpenMoHAA source code.

OpenMoHAA source code is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the License,
or (at your option) any later version.

OpenMoHAA source code is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenMoHAA source code; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
===========================================================================
*/

const char *fallbackShader_bokeh_vp =
"attribute vec3 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"varying vec2 var_TexCoords;\n"
"void main()\n"
"{\n"
"gl_Position = u_ModelViewProjectionMatrix * vec4( attr_Position, 1.0 );\n"
"var_TexCoords = attr_TexCoord0.st;\n"
"}\n";

const char *fallbackShader_bokeh_fp =
"uniform sampler2D u_TextureMap;\n"
"uniform vec4 u_Color;\n"
"uniform vec2 u_InvTexRes;\n"
"varying vec2 var_TexCoords;\n"
"void main()\n"
"{\n"
"vec4 color;\n"
"vec2 tc;\n"
"float c[ 5 ] = float[ 5 ]( 1.0, 0.9238795325, 0.7071067812, 0.3826834324, 0.0 );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( c[ 0 ], c[ 4 ] );  color = texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( c[ 1 ], c[ 3 ] );  color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( c[ 2 ], c[ 2 ] );  color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( c[ 3 ], c[ 1 ] );  color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( c[ 4 ], c[ 0 ] );  color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( c[ 1 ], -c[ 3 ] );  color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( c[ 2 ], -c[ 2 ] );  color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( c[ 3 ], -c[ 1 ] );  color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( c[ 4 ], -c[ 0 ] );  color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( -c[ 0 ], c[ 4 ] );  color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( -c[ 1 ], c[ 3 ] );  color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( -c[ 2 ], c[ 2 ] );  color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( -c[ 3 ], c[ 1 ] );  color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( -c[ 1 ], -c[ 3 ] );  color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( -c[ 2 ], -c[ 2 ] );  color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( -c[ 3 ], -c[ 1 ] );  color += texture2D( u_TextureMap, tc );\n"
"gl_FragColor = color * 0.0625 * u_Color;\n"
"}\n";

const char *fallbackShader_calclevels4x_vp =
"attribute vec3 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"varying vec2 var_TexCoords;\n"
"void main()\n"
"{\n"
"gl_Position = u_ModelViewProjectionMatrix * vec4( attr_Position, 1.0 );\n"
"var_TexCoords = attr_TexCoord0.st;\n"
"}\n";

const char *fallbackShader_calclevels4x_fp =
"uniform sampler2D u_TextureMap;\n"
"uniform vec4 u_Color;\n"
"uniform vec2 u_InvTexRes;\n"
"varying vec2 var_TexCoords;\n"
"const vec3 LUMINANCE_VECTOR = vec3( 0.2125, 0.7154, 0.0721 );\n"
"vec3 GetValues( vec2 offset, vec3 current )\n"
"{\n"
"vec2 tc = var_TexCoords + u_InvTexRes * offset;\n"
"vec3 minAvgMax = texture2D( u_TextureMap, tc ).rgb;\n"
"#ifdef FIRST_PASS\n"
"#if defined(r_framebufferGamma)\n"
"minAvgMax = pow( minAvgMax, vec3( r_framebufferGamma ) );\n"
"#endif\n"
"float lumi = max( dot( LUMINANCE_VECTOR, minAvgMax ), 0.000001 );\n"
"float loglumi = clamp( log2( lumi ), -10.0, 10.0 );\n"
"minAvgMax = vec3( loglumi * 0.05 + 0.5 );\n"
"#endif\n"
"return vec3( min( current.x, minAvgMax.x ), current.y + minAvgMax.y, max( current.z, minAvgMax.z ) );\n"
"}\n"
"void main()\n"
"{\n"
"vec3 current = vec3( 1.0, 0.0, 0.0 );\n"
"#ifdef FIRST_PASS\n"
"current = GetValues( vec2( 0.0, 0.0 ), current );\n"
"#else\n"
"current = GetValues( vec2( -1.5, -1.5 ), current );\n"
"current = GetValues( vec2( -0.5, -1.5 ), current );\n"
"current = GetValues( vec2( 0.5, -1.5 ), current );\n"
"current = GetValues( vec2( 1.5, -1.5 ), current );\n"
"current = GetValues( vec2( -1.5, -0.5 ), current );\n"
"current = GetValues( vec2( -0.5, -0.5 ), current );\n"
"current = GetValues( vec2( 0.5, -0.5 ), current );\n"
"current = GetValues( vec2( 1.5, -0.5 ), current );\n"
"current = GetValues( vec2( -1.5, 0.5 ), current );\n"
"current = GetValues( vec2( -0.5, 0.5 ), current );\n"
"current = GetValues( vec2( 0.5, 0.5 ), current );\n"
"current = GetValues( vec2( 1.5, 0.5 ), current );\n"
"current = GetValues( vec2( -1.5, 1.5 ), current );\n"
"current = GetValues( vec2( -0.5, 1.5 ), current );\n"
"current = GetValues( vec2( 0.5, 1.5 ), current );\n"
"current = GetValues( vec2( 1.5, 1.5 ), current );\n"
"current.y *= 0.0625;\n"
"#endif\n"
"gl_FragColor = vec4( current, 1.0f );\n"
"}\n";

const char *fallbackShader_depthblur_vp =
"attribute vec4 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"varying vec2 var_ScreenTex;\n"
"void main()\n"
"{\n"
"gl_Position = attr_Position;\n"
"var_ScreenTex = attr_TexCoord0.xy;\n"
"}\n";

const char *fallbackShader_depthblur_fp =
"uniform sampler2D u_ScreenImageMap;\n"
"uniform sampler2D u_ScreenDepthMap;\n"
"uniform vec4 u_ViewInfo;\n"
"varying vec2 var_ScreenTex;\n"
"float gauss[ 4 ] = float[ 4 ]( 0.40, 0.24, 0.054, 0.0044 );\n"
"#define GAUSS_SIZE 4\n"
"float getLinearDepth( sampler2D depthMap, const vec2 tex, const float zFarDivZNear )\n"
"{\n"
"float sampleZDivW = texture2D( depthMap, tex ).r;\n"
"return 1.0 / mix( zFarDivZNear, 1.0, sampleZDivW );\n"
"}\n"
"vec4 depthGaussian1D( sampler2D imageMap, sampler2D depthMap, vec2 tex, float zFarDivZNear, float zFar )\n"
"{\n"
"float scale = 1.0 / 256.0;\n"
"#if defined(USE_HORIZONTAL_BLUR)\n"
"vec2 direction = vec2( 1.0, 0.0 ) * scale;\n"
"#else // if defined(USE_VERTICAL_BLUR)\n"
"vec2 direction = vec2( 0.0, 1.0 ) * scale;\n"
"#endif\n"
"float depthCenter = zFar * getLinearDepth( depthMap, tex, zFarDivZNear );\n"
"vec2 centerSlope = vec2( dFdx( depthCenter ), dFdy( depthCenter ) ) / vec2( dFdx( tex.x ), dFdy( tex.y ) );\n"
"vec4 result = texture2D( imageMap, tex ) * gauss[ 0 ];\n"
"float total = gauss[ 0 ];\n"
"int i, j;\n"
"for( i = 0; i < 2; i++ )\n"
"{\n"
"for( j = 1; j < GAUSS_SIZE; j++ )\n"
"{\n"
"vec2 offset = direction * j;\n"
"float depthSample = zFar * getLinearDepth( depthMap, tex + offset, zFarDivZNear );\n"
"float depthExpected = depthCenter + dot( centerSlope, offset );\n"
"if( abs( depthSample - depthExpected ) < 5.0 )\n"
"{\n"
"result += texture2D( imageMap, tex + offset ) * gauss[ j ];\n"
"total += gauss[ j ];\n"
"}\n"
"}\n"
"direction = -direction;\n"
"}\n"
"return result / total;\n"
"}\n"
"void main()\n"
"{\n"
"gl_FragColor = depthGaussian1D( u_ScreenImageMap, u_ScreenDepthMap, var_ScreenTex, u_ViewInfo.x, u_ViewInfo.y );\n"
"}\n";

const char *fallbackShader_dlight_vp =
"attribute vec3 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"attribute vec3 attr_Normal;\n"
"uniform vec4 u_DlightInfo;\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"uniform int u_DeformGen;\n"
"uniform float u_DeformParams[ 5 ];\n"
"uniform float u_Time;\n"
"#endif\n"
"uniform vec4 u_Color;\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"varying vec2 var_Tex1;\n"
"varying vec4 var_Color;\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"vec3 DeformPosition( const vec3 pos, const vec3 normal, const vec2 st )\n"
"{\n"
"if( u_DeformGen == 0 )\n"
"{\n"
"return pos;\n"
"}\n"
"float base = u_DeformParams[ 0 ];\n"
"float amplitude = u_DeformParams[ 1 ];\n"
"float phase = u_DeformParams[ 2 ];\n"
"float frequency = u_DeformParams[ 3 ];\n"
"float spread = u_DeformParams[ 4 ];\n"
"if( u_DeformGen == DGEN_BULGE )\n"
"{\n"
"phase *= st.x;\n"
"}\n"
"else // if (u_DeformGen <= DGEN_WAVE_INVERSE_SAWTOOTH)\n"
"{\n"
"phase += dot( pos.xyz, vec3( spread ) );\n"
"}\n"
"float value = phase + ( u_Time * frequency );\n"
"float func;\n"
"if( u_DeformGen == DGEN_WAVE_SIN )\n"
"{\n"
"func = sin( value * 2.0 * M_PI );\n"
"}\n"
"else if( u_DeformGen == DGEN_WAVE_SQUARE )\n"
"{\n"
"func = sign( 0.5 - fract( value ) );\n"
"}\n"
"else if( u_DeformGen == DGEN_WAVE_TRIANGLE )\n"
"{\n"
"func = abs( fract( value + 0.75 ) - 0.5 ) * 4.0 - 1.0;\n"
"}\n"
"else if( u_DeformGen == DGEN_WAVE_SAWTOOTH )\n"
"{\n"
"func = fract( value );\n"
"}\n"
"else if( u_DeformGen == DGEN_WAVE_INVERSE_SAWTOOTH )\n"
"{\n"
"func = ( 1.0 - fract( value ) );\n"
"}\n"
"else // if (u_DeformGen == DGEN_BULGE)\n"
"{\n"
"func = sin( value );\n"
"}\n"
"return pos + normal * ( base + func * amplitude );\n"
"}\n"
"#endif\n"
"void main()\n"
"{\n"
"vec3 position = attr_Position;\n"
"vec3 normal = attr_Normal;\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"position = DeformPosition( position, normal, attr_TexCoord0.st );\n"
"#endif\n"
"gl_Position = u_ModelViewProjectionMatrix * vec4( position, 1.0 );\n"
"vec3 dist = u_DlightInfo.xyz - position;\n"
"var_Tex1 = dist.xy * u_DlightInfo.a + vec2( 0.5 );\n"
"float dlightmod = step( 0.0, dot( dist, normal ) );\n"
"dlightmod *= clamp( 2.0 * ( 1.0 - abs( dist.z ) * u_DlightInfo.a ), 0.0, 1.0 );\n"
"var_Color = u_Color * dlightmod;\n"
"}\n";

const char *fallbackShader_dlight_fp =
"uniform sampler2D u_DiffuseMap;\n"
"varying vec2 var_Tex1;\n"
"varying vec4 var_Color;\n"
"void main()\n"
"{\n"
"vec4 color = texture2D( u_DiffuseMap, var_Tex1 );\n"
"gl_FragColor = color * var_Color;\n"
"}\n";

const char *fallbackShader_down4x_vp =
"attribute vec3 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"varying vec2 var_TexCoords;\n"
"void main()\n"
"{\n"
"gl_Position = u_ModelViewProjectionMatrix * vec4( attr_Position, 1.0 );\n"
"var_TexCoords = attr_TexCoord0.st;\n"
"}\n";

const char *fallbackShader_down4x_fp =
"uniform sampler2D u_TextureMap;\n"
"uniform vec2 u_InvTexRes;\n"
"varying vec2 var_TexCoords;\n"
"void main()\n"
"{\n"
"vec4 color;\n"
"vec2 tc;\n"
"tc = var_TexCoords + u_InvTexRes * vec2( -1.5, -1.5 );  color = texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( -0.5, -1.5 );  color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( 0.5, -1.5 );  color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( 1.5, -1.5 );  color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( -1.5, -0.5 ); color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( -0.5, -0.5 ); color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( 0.5, -0.5 ); color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( 1.5, -0.5 ); color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( -1.5, 0.5 ); color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( -0.5, 0.5 ); color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( 0.5, 0.5 ); color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( 1.5, 0.5 ); color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( -1.5, 1.5 );  color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( -0.5, 1.5 );  color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( 0.5, 1.5 );  color += texture2D( u_TextureMap, tc );\n"
"tc = var_TexCoords + u_InvTexRes * vec2( 1.5, 1.5 );  color += texture2D( u_TextureMap, tc );\n"
"color *= 0.0625;\n"
"gl_FragColor = color;\n"
"}\n";

const char *fallbackShader_fogpass_vp =
"attribute vec3 attr_Position;\n"
"attribute vec3 attr_Normal;\n"
"attribute vec4 attr_TexCoord0;\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"attribute vec3 attr_Position2;\n"
"attribute vec3 attr_Normal2;\n"
"#endif\n"
"uniform vec4 u_FogDistance;\n"
"uniform vec4 u_FogDepth;\n"
"uniform float u_FogEyeT;\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"uniform int u_DeformGen;\n"
"uniform float u_DeformParams[ 5 ];\n"
"#endif\n"
"uniform float u_Time;\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"uniform float u_VertexLerp;\n"
"#endif\n"
"uniform vec4 u_Color;\n"
"varying float var_Scale;\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"vec3 DeformPosition( const vec3 pos, const vec3 normal, const vec2 st )\n"
"{\n"
"if( u_DeformGen == 0 )\n"
"{\n"
"return pos;\n"
"}\n"
"float base = u_DeformParams[ 0 ];\n"
"float amplitude = u_DeformParams[ 1 ];\n"
"float phase = u_DeformParams[ 2 ];\n"
"float frequency = u_DeformParams[ 3 ];\n"
"float spread = u_DeformParams[ 4 ];\n"
"if( u_DeformGen == DGEN_BULGE )\n"
"{\n"
"phase *= st.x;\n"
"}\n"
"else\n"
"{\n"
"phase += dot( pos.xyz, vec3( spread ) );\n"
"}\n"
"float value = phase + ( u_Time * frequency );\n"
"float func;\n"
"if( u_DeformGen == DGEN_WAVE_SIN )\n"
"{\n"
"func = sin( value * 2.0 * M_PI );\n"
"}\n"
"else if( u_DeformGen == DGEN_WAVE_SQUARE )\n"
"{\n"
"func = sign( 0.5 - fract( value ) );\n"
"}\n"
"else if( u_DeformGen == DGEN_WAVE_TRIANGLE )\n"
"{\n"
"func = abs( fract( value + 0.75 ) - 0.5 ) * 4.0 - 1.0;\n"
"}\n"
"else if( u_DeformGen == DGEN_WAVE_SAWTOOTH )\n"
"{\n"
"func = fract( value );\n"
"}\n"
"else if( u_DeformGen == DGEN_WAVE_INVERSE_SAWTOOTH )\n"
"{\n"
"func = ( 1.0 - fract( value ) );\n"
"}\n"
"else\n"
"{\n"
"func = sin( value );\n"
"}\n"
"return pos + normal * ( base + func * amplitude );\n"
"}\n"
"#endif\n"
"float CalcFog( vec3 position )\n"
"{\n"
"float s = dot( vec4( position, 1.0 ), u_FogDistance ) * 8.0;\n"
"float t = dot( vec4( position, 1.0 ), u_FogDepth );\n"
"float eyeOutside = float( u_FogEyeT < 0.0 );\n"
"float fogged = float( t >= eyeOutside );\n"
"t += 1e-6;\n"
"t *= fogged / ( t - u_FogEyeT * eyeOutside );\n"
"return s * t;\n"
"}\n"
"void main()\n"
"{\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"vec3 position = mix( attr_Position, attr_Position2, u_VertexLerp );\n"
"vec3 normal = mix( attr_Normal, attr_Normal2, u_VertexLerp );\n"
"#else\n"
"vec3 position = attr_Position;\n"
"vec3 normal = attr_Normal;\n"
"#endif\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"position.xyz = DeformPosition( position.xyz, normal, attr_TexCoord0.st );\n"
"#endif\n"
"gl_Position = u_ModelViewProjectionMatrix * vec4( position, 1.0 );\n"
"var_Scale = CalcFog( position ) * u_Color.a * u_Color.a;\n"
"}\n";

const char *fallbackShader_fogpass_fp =
"uniform vec4  u_Color;\n"
"varying float var_Scale;\n"
"void main()\n"
"{\n"
"gl_FragColor = u_Color;\n"
"gl_FragColor.a = sqrt( clamp( var_Scale, 0.0, 1.0 ) );\n"
"}\n";

const char *fallbackShader_generic_vp =
"attribute vec3 attr_Position;\n"
"attribute vec3 attr_Normal;\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"attribute vec3 attr_Position2;\n"
"attribute vec3 attr_Normal2;\n"
"#endif\n"
"attribute vec4 attr_Color;\n"
"attribute vec4 attr_TexCoord0;\n"
"#if defined(USE_TCGEN)\n"
"attribute vec4 attr_TexCoord1;\n"
"#endif\n"
"uniform vec4   u_DiffuseTexMatrix;\n"
"uniform vec4   u_DiffuseTexOffTurb;\n"
"#if defined(USE_TCGEN) || defined(USE_RGBAGEN)\n"
"uniform vec3   u_LocalViewOrigin;\n"
"#endif\n"
"#if defined(USE_TCGEN)\n"
"uniform int    u_TCGen0;\n"
"uniform vec3   u_TCGen0Vector0;\n"
"uniform vec3   u_TCGen0Vector1;\n"
"#endif\n"
"#if defined(USE_FOG)\n"
"uniform vec4   u_FogDistance;\n"
"uniform vec4   u_FogDepth;\n"
"uniform float  u_FogEyeT;\n"
"uniform vec4   u_FogColorMask;\n"
"#endif\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"uniform int    u_DeformGen;\n"
"uniform float  u_DeformParams[ 5 ];\n"
"uniform float  u_Time;\n"
"#endif\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"uniform vec4   u_BaseColor;\n"
"uniform vec4   u_VertColor;\n"
"#if defined(USE_RGBAGEN)\n"
"uniform int    u_ColorGen;\n"
"uniform int    u_AlphaGen;\n"
"uniform vec3   u_AmbientLight;\n"
"uniform vec3   u_DirectedLight;\n"
"uniform vec3   u_ModelLightDir;\n"
"uniform float  u_PortalRange;\n"
"#endif\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"uniform float  u_VertexLerp;\n"
"#endif\n"
"varying vec2   var_DiffuseTex;\n"
"varying vec4   var_Color;\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"vec3 DeformPosition( const vec3 pos, const vec3 normal, const vec2 st )\n"
"{\n"
"float base = u_DeformParams[ 0 ];\n"
"float amplitude = u_DeformParams[ 1 ];\n"
"float phase = u_DeformParams[ 2 ];\n"
"float frequency = u_DeformParams[ 3 ];\n"
"float spread = u_DeformParams[ 4 ];\n"
"if( u_DeformGen == DGEN_BULGE )\n"
"{\n"
"phase *= st.x;\n"
"}\n"
"else\n"
"{\n"
"phase += dot( pos.xyz, vec3( spread ) );\n"
"}\n"
"float value = phase + ( u_Time * frequency );\n"
"float func;\n"
"if( u_DeformGen == DGEN_WAVE_SIN )\n"
"{\n"
"func = sin( value * 2.0 * M_PI );\n"
"}\n"
"else if( u_DeformGen == DGEN_WAVE_SQUARE )\n"
"{\n"
"func = sign( fract( 0.5 - value ) );\n"
"}\n"
"else if( u_DeformGen == DGEN_WAVE_TRIANGLE )\n"
"{\n"
"func = abs( fract( value + 0.75 ) - 0.5 ) * 4.0 - 1.0;\n"
"}\n"
"else if( u_DeformGen == DGEN_WAVE_SAWTOOTH )\n"
"{\n"
"func = fract( value );\n"
"}\n"
"else if( u_DeformGen == DGEN_WAVE_INVERSE_SAWTOOTH )\n"
"{\n"
"func = ( 1.0 - fract( value ) );\n"
"}\n"
"else\n"
"{\n"
"func = sin( value );\n"
"}\n"
"return pos + normal * ( base + func * amplitude );\n"
"}\n"
"#endif\n"
"#if defined(USE_TCGEN)\n"
"vec2 GenTexCoords( int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1 )\n"
"{\n"
"vec2 tex = attr_TexCoord0.st;\n"
"if( TCGen == TCGEN_LIGHTMAP )\n"
"{\n"
"tex = attr_TexCoord1.st;\n"
"}\n"
"else if( TCGen == TCGEN_ENVIRONMENT_MAPPED )\n"
"{\n"
"vec3 viewer = normalize( u_LocalViewOrigin - position );\n"
"vec2 ref = reflect( viewer, normal ).yz;\n"
"tex.s = ref.x * -0.5 + 0.5;\n"
"tex.t = ref.y *  0.5 + 0.5;\n"
"}\n"
"else if( TCGen == TCGEN_VECTOR )\n"
"{\n"
"tex = vec2( dot( position, TCGenVector0 ), dot( position, TCGenVector1 ) );\n"
"}\n"
"return tex;\n"
"}\n"
"#endif\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords( vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb )\n"
"{\n"
"float amplitude = offTurb.z;\n"
"float phase = offTurb.w * 2.0 * M_PI;\n"
"vec2 st2;\n"
"st2.x = st.x * texMatrix.x + ( st.y * texMatrix.z + offTurb.x );\n"
"st2.y = st.x * texMatrix.y + ( st.y * texMatrix.w + offTurb.y );\n"
"vec2 offsetPos = vec2( position.x + position.z, position.y );\n"
"vec2 texOffset = sin( offsetPos * ( 2.0 * M_PI / 1024.0 ) + vec2( phase ) );\n"
"return st2 + texOffset * amplitude;\n"
"}\n"
"#endif\n"
"#if defined(USE_RGBAGEN)\n"
"vec4 CalcColor( vec3 position, vec3 normal )\n"
"{\n"
"vec4 color = u_VertColor * attr_Color + u_BaseColor;\n"
"if( u_ColorGen == CGEN_LIGHTING_DIFFUSE )\n"
"{\n"
"float incoming = clamp( dot( normal, u_ModelLightDir ), 0.0, 1.0 );\n"
"color.rgb = clamp( u_DirectedLight * incoming + u_AmbientLight, 0.0, 1.0 );\n"
"}\n"
"vec3 viewer = u_LocalViewOrigin - position;\n"
"if( u_AlphaGen == AGEN_LIGHTING_SPECULAR )\n"
"{\n"
"vec3 lightDir = normalize( vec3( -960.0, 1980.0, 96.0 ) - position );\n"
"vec3 reflected = -reflect( lightDir, normal );\n"
"color.a = clamp( dot( reflected, normalize( viewer ) ), 0.0, 1.0 );\n"
"color.a *= color.a;\n"
"color.a *= color.a;\n"
"}\n"
"else if( u_AlphaGen == AGEN_PORTAL )\n"
"{\n"
"color.a = clamp( length( viewer ) / u_PortalRange, 0.0, 1.0 );\n"
"}\n"
"return color;\n"
"}\n"
"#endif\n"
"#if defined(USE_FOG)\n"
"float CalcFog( vec3 position )\n"
"{\n"
"float s = dot( vec4( position, 1.0 ), u_FogDistance ) * 8.0;\n"
"float t = dot( vec4( position, 1.0 ), u_FogDepth );\n"
"float eyeOutside = float( u_FogEyeT < 0.0 );\n"
"float fogged = float( t >= eyeOutside );\n"
"t += 1e-6;\n"
"t *= fogged / ( t - u_FogEyeT * eyeOutside );\n"
"return s * t;\n"
"}\n"
"#endif\n"
"void main()\n"
"{\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"vec3 position = mix( attr_Position, attr_Position2, u_VertexLerp );\n"
"vec3 normal = mix( attr_Normal, attr_Normal2, u_VertexLerp );\n"
"#else\n"
"vec3 position = attr_Position;\n"
"vec3 normal = attr_Normal;\n"
"#endif\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"position = DeformPosition( position, normal, attr_TexCoord0.st );\n"
"#endif\n"
"gl_Position = u_ModelViewProjectionMatrix * vec4( position, 1.0 );\n"
"#if defined(USE_TCGEN)\n"
"vec2 tex = GenTexCoords( u_TCGen0, position, normal, u_TCGen0Vector0, u_TCGen0Vector1 );\n"
"#else\n"
"vec2 tex = attr_TexCoord0.st;\n"
"#endif\n"
"#if defined(USE_TCMOD)\n"
"var_DiffuseTex = ModTexCoords( tex, position, u_DiffuseTexMatrix, u_DiffuseTexOffTurb );\n"
"#else\n"
"var_DiffuseTex = tex;\n"
"#endif\n"
"#if defined(USE_RGBAGEN)\n"
"var_Color = CalcColor( position, normal );\n"
"#else\n"
"var_Color = u_VertColor * attr_Color + u_BaseColor;\n"
"#endif\n"
"#if defined(USE_FOG)\n"
"var_Color *= vec4( 1.0 ) - u_FogColorMask * sqrt( clamp( CalcFog( position ), 0.0, 1.0 ) );\n"
"#endif\n"
"}\n";

const char *fallbackShader_generic_fp =
"uniform sampler2D u_DiffuseMap;\n"
"varying vec2 var_DiffuseTex;\n"
"varying vec4 var_Color;\n"
"void main()\n"
"{\n"
"vec4 color = texture2D( u_DiffuseMap, var_DiffuseTex );\n"
"gl_FragColor = color * var_Color;\n"
"}\n";

const char *fallbackShader_lightall_vp =
"attribute vec4 attr_TexCoord0;\n"
"#if defined(USE_LIGHTMAP) || defined(USE_TCGEN)\n"
"attribute vec4 attr_TexCoord1;\n"
"#endif\n"
"attribute vec4 attr_Color;\n"
"attribute vec3 attr_Position;\n"
"attribute vec3 attr_Normal;\n"
"#if defined(USE_VERT_TANGENT_SPACE)\n"
"attribute vec4 attr_Tangent;\n"
"#endif\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"attribute vec3 attr_Position2;\n"
"attribute vec3 attr_Normal2;\n"
"#if defined(USE_VERT_TANGENT_SPACE)\n"
"attribute vec4 attr_Tangent2;\n"
"#endif\n"
"#endif\n"
"#if defined(USE_LIGHT) && !defined(USE_LIGHT_VECTOR)\n"
"attribute vec3 attr_LightDirection;\n"
"#endif\n"
"#if defined(USE_DELUXEMAP)\n"
"uniform vec4 u_EnableTextures; // x = normal, y = deluxe, z = specular, w = cube\n"
"#endif\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"uniform vec3 u_ViewOrigin;\n"
"#endif\n"
"#if defined(USE_TCGEN)\n"
"uniform int u_TCGen0;\n"
"uniform vec3 u_TCGen0Vector0;\n"
"uniform vec3 u_TCGen0Vector1;\n"
"uniform vec3 u_LocalViewOrigin;\n"
"#endif\n"
"#if defined(USE_TCMOD)\n"
"uniform vec4 u_DiffuseTexMatrix;\n"
"uniform vec4 u_DiffuseTexOffTurb;\n"
"#endif\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"uniform vec4 u_BaseColor;\n"
"uniform vec4 u_VertColor;\n"
"#if defined(USE_MODELMATRIX)\n"
"uniform mat4 u_ModelMatrix;\n"
"#endif\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"uniform float  u_VertexLerp;\n"
"#endif\n"
"#if defined(USE_LIGHT_VECTOR)\n"
"uniform vec4 u_LightOrigin;\n"
"uniform float u_LightRadius;\n"
"#if defined(USE_FAST_LIGHT)\n"
"uniform vec3 u_DirectedLight;\n"
"uniform vec3 u_AmbientLight;\n"
"#endif\n"
"#endif\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"uniform vec4 u_PrimaryLightOrigin;\n"
"uniform float u_PrimaryLightRadius;\n"
"#endif\n"
"varying vec4 var_TexCoords;\n"
"varying vec4 var_Color;\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"#if defined(USE_VERT_TANGENT_SPACE)\n"
"varying vec4 var_Normal;\n"
"varying vec4 var_Tangent;\n"
"varying vec4 var_Bitangent;\n"
"#else\n"
"varying vec3 var_Normal;\n"
"varying vec3 var_ViewDir;\n"
"#endif\n"
"#endif\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"varying vec4   var_LightDir;\n"
"#endif\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"varying vec4   var_PrimaryLightDir;\n"
"#endif\n"
"#if defined(USE_TCGEN)\n"
"vec2 GenTexCoords( int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1 )\n"
"{\n"
"vec2 tex = attr_TexCoord0.st;\n"
"\n"
"if( TCGen == TCGEN_LIGHTMAP )\n"
"{\n"
"tex = attr_TexCoord1.st;\n"
"}\n"
"else if( TCGen == TCGEN_ENVIRONMENT_MAPPED )\n"
"{\n"
"vec3 viewer = normalize( u_LocalViewOrigin - position );\n"
"vec2 ref = reflect( viewer, normal ).yz;\n"
"tex.s = ref.x * -0.5 + 0.5;\n"
"tex.t = ref.y *  0.5 + 0.5;\n"
"}\n"
"else if( TCGen == TCGEN_VECTOR )\n"
"{\n"
"tex = vec2( dot( position, TCGenVector0 ), dot( position, TCGenVector1 ) );\n"
"}\n"
"return tex;\n"
"}\n"
"#endif\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords( vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb )\n"
"{\n"
"float amplitude = offTurb.z;\n"
"float phase = offTurb.w * 2.0 * M_PI;\n"
"vec2 st2;\n"
"st2.x = st.x * texMatrix.x + ( st.y * texMatrix.z + offTurb.x );\n"
"st2.y = st.x * texMatrix.y + ( st.y * texMatrix.w + offTurb.y );\n"
"vec2 offsetPos = vec2( position.x + position.z, position.y );\n"
"vec2 texOffset = sin( offsetPos * ( 2.0 * M_PI / 1024.0 ) + vec2( phase ) );\n"
"return st2 + texOffset * amplitude;\n"
"}\n"
"#endif\n"
"float CalcLightAttenuation( float point, float normDist )\n"
"{\n"
"float attenuation = ( 0.5 * normDist - 1.5 ) * point + 1.0;\n"
"#if defined(NO_LIGHT_CLAMP)\n"
"attenuation = max( attenuation, 0.0 );\n"
"#else\n"
"attenuation = clamp( attenuation, 0.0, 1.0 );\n"
"#endif\n"
"return attenuation;\n"
"}\n"
"void main()\n"
"{\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"vec3 position = mix( attr_Position, attr_Position2, u_VertexLerp );\n"
"vec3 normal = mix( attr_Normal, attr_Normal2, u_VertexLerp );\n"
"#if defined(USE_VERT_TANGENT_SPACE) && defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"vec3 tangent = mix( attr_Tangent.xyz, attr_Tangent2.xyz, u_VertexLerp );\n"
"#endif\n"
"#else\n"
"vec3 position = attr_Position;\n"
"vec3 normal = attr_Normal;\n"
"#if defined(USE_VERT_TANGENT_SPACE) && defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"vec3 tangent = attr_Tangent.xyz;\n"
"#endif\n"
"#endif\n"
"#if defined(USE_TCGEN)\n"
"vec2 texCoords = GenTexCoords( u_TCGen0, position, normal, u_TCGen0Vector0, u_TCGen0Vector1 );\n"
"#else\n"
"vec2 texCoords = attr_TexCoord0.st;\n"
"#endif\n"
"#if defined(USE_TCMOD)\n"
"var_TexCoords.xy = ModTexCoords( texCoords, position, u_DiffuseTexMatrix, u_DiffuseTexOffTurb );\n"
"#else\n"
"var_TexCoords.xy = texCoords;\n"
"#endif\n"
"gl_Position = u_ModelViewProjectionMatrix * vec4( position, 1.0 );\n"
"#if defined(USE_MODELMATRIX)\n"
"position = ( u_ModelMatrix * vec4( position, 1.0 ) ).xyz;\n"
"normal = ( u_ModelMatrix * vec4( normal, 0.0 ) ).xyz;\n"
"#if defined(USE_VERT_TANGENT_SPACE) && defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"tangent = ( u_ModelMatrix * vec4( tangent, 0.0 ) ).xyz;\n"
"#endif\n"
"#endif\n"
"#if defined(USE_VERT_TANGENT_SPACE) && defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"vec3 bitangent = cross( normal, tangent ) * attr_Tangent.w;\n"
"#endif\n"
"#if defined(USE_LIGHT_VECTOR)\n"
"vec3 L = u_LightOrigin.xyz - ( position * u_LightOrigin.w );\n"
"#elif defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"vec3 L = attr_LightDirection;\n"
"#if defined(USE_MODELMATRIX)\n"
"L = ( u_ModelMatrix * vec4( L, 0.0 ) ).xyz;\n"
"#endif\n"
"#endif\n"
"#if defined(USE_LIGHTMAP)\n"
"var_TexCoords.zw = attr_TexCoord1.st;\n"
"#endif\n"
"var_Color = u_VertColor * attr_Color + u_BaseColor;\n"
"#if defined(USE_LIGHT_VECTOR) && defined(USE_FAST_LIGHT)\n"
"float sqrLightDist = dot( L, L );\n"
"float attenuation = CalcLightAttenuation( u_LightOrigin.w, u_LightRadius * u_LightRadius / sqrLightDist );\n"
"float NL = clamp( dot( normalize( normal ), L ) / sqrt( sqrLightDist ), 0.0, 1.0 );\n"
"var_Color.rgb *= u_DirectedLight * ( attenuation * NL ) + u_AmbientLight;\n"
"#endif\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"var_PrimaryLightDir.xyz = u_PrimaryLightOrigin.xyz - ( position * u_PrimaryLightOrigin.w );\n"
"var_PrimaryLightDir.w = u_PrimaryLightRadius * u_PrimaryLightRadius;\n"
"#endif\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"#if defined(USE_LIGHT_VECTOR)\n"
"var_LightDir = vec4( L, u_LightRadius * u_LightRadius );\n"
"#else\n"
"var_LightDir = vec4( L, 0.0 );\n"
"#endif\n"
"#if defined(USE_DELUXEMAP)\n"
"var_LightDir -= u_EnableTextures.y * var_LightDir;\n"
"#endif\n"
"#endif\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"vec3 viewDir = u_ViewOrigin - position;\n"
"#if defined(USE_VERT_TANGENT_SPACE)\n"
"// store view direction in tangent space to save on varyings\n"
"var_Normal = vec4( normal, viewDir.x );\n"
"var_Tangent = vec4( tangent, viewDir.y );\n"
"var_Bitangent = vec4( bitangent, viewDir.z );\n"
"#else\n"
"var_Normal = normal;\n"
"var_ViewDir = viewDir;\n"
"#endif\n"
"#endif\n"
"}\n";

const char *fallbackShader_lightall_fp =
"uniform sampler2D u_DiffuseMap;\n"
"#if defined(USE_LIGHTMAP)\n"
"uniform sampler2D u_LightMap;\n"
"#endif\n"
"#if defined(USE_NORMALMAP)\n"
"uniform sampler2D u_NormalMap;\n"
"#endif\n"
"#if defined(USE_DELUXEMAP)\n"
"uniform sampler2D u_DeluxeMap;\n"
"#endif\n"
"#if defined(USE_SPECULARMAP)\n"
"uniform sampler2D u_SpecularMap;\n"
"#endif\n"
"#if defined(USE_SHADOWMAP)\n"
"uniform sampler2D u_ShadowMap;\n"
"#endif\n"
"#if defined(USE_CUBEMAP)\n"
"uniform samplerCube u_CubeMap;\n"
"#endif\n"
"#if defined(USE_NORMALMAP) || defined(USE_DELUXEMAP) || defined(USE_SPECULARMAP) || defined(USE_CUBEMAP)\n"
"uniform vec4 u_EnableTextures;\n"
"#endif\n"
"#if defined(USE_LIGHT_VECTOR) && !defined(USE_FAST_LIGHT)\n"
"uniform vec3 u_DirectedLight;\n"
"uniform vec3 u_AmbientLight;\n"
"#endif\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"uniform vec3 u_PrimaryLightColor;\n"
"uniform vec3 u_PrimaryLightAmbient;\n"
"#endif\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"uniform vec4 u_NormalScale;\n"
"uniform vec4 u_SpecularScale;\n"
"#endif\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"#if defined(USE_CUBEMAP)\n"
"uniform vec4 u_CubeMapInfo;\n"
"#endif\n"
"#endif\n"
"varying vec4 var_TexCoords;\n"
"varying vec4 var_Color;\n"
"#if (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT))\n"
"#if defined(USE_VERT_TANGENT_SPACE)\n"
"varying vec4 var_Normal;\n"
"varying vec4 var_Tangent;\n"
"varying vec4 var_Bitangent;\n"
"#else\n"
"varying vec3 var_Normal;\n"
"varying vec3 var_ViewDir;\n"
"#endif\n"
"#endif\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"varying vec4 var_LightDir;\n"
"#endif\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"varying vec4 var_PrimaryLightDir;\n"
"#endif\n"
"#define EPSILON 0.00000001\n"
"#if defined(USE_PARALLAXMAP)\n"
"float SampleDepth( sampler2D normalMap, vec2 t )\n"
"{\n"
"#if defined(SWIZZLE_NORMALMAP)\n"
"return 1.0 - texture2D( normalMap, t ).r;\n"
"#else\n"
"return 1.0 - texture2D( normalMap, t ).a;\n"
"#endif\n"
"}\n"
"float RayIntersectDisplaceMap( vec2 dp, vec2 ds, sampler2D normalMap )\n"
"{\n"
"const int linearSearchSteps = 16;\n"
"const int binarySearchSteps = 6;\n"
"float size = 1.0 / float( linearSearchSteps );\n"
"float depth = 0.0;\n"
"float bestDepth = 1.0;\n"
"float texDepth = 0.0;\n"
"float prevT = SampleDepth( normalMap, dp );\n"
"float prevTexDepth = prevT;\n"
"for( int i = 0; i < linearSearchSteps - 1; ++i )\n"
"{\n"
"depth += size;\n"
"float t = SampleDepth( normalMap, dp + ds * depth );\n"
"if( bestDepth > 0.996 )\n"
"if( depth >= t )\n"
"{\n"
"bestDepth = depth;\n"
"texDepth = t;\n"
"prevTexDepth = prevT;\n"
"}\n"
"prevT = t;\n"
"}\n"
"depth = bestDepth;\n"
"#if !defined (USE_RELIEFMAP)\n"
"float div = 1.0 / ( 1.0 + ( prevTexDepth - texDepth ) * float( linearSearchSteps ) );\n"
"bestDepth -= ( depth - size - prevTexDepth ) * div;\n"
"#else\n"
"for( int i = 0; i < binarySearchSteps; ++i )\n"
"{\n"
"size *= 0.5;\n"
"float t = SampleDepth( normalMap, dp + ds * depth );\n"
"if( depth >= t )\n"
"{\n"
"bestDepth = depth;\n"
"depth -= 2.0 * size;\n"
"}\n"
"depth += size;\n"
"}\n"
"#endif\n"
"return bestDepth;\n"
"}\n"
"#endif\n"
"\n"
"vec3 CalcDiffuse( vec3 diffuseAlbedo, vec3 N, vec3 L, vec3 E, float NE, float NL, float shininess )\n"
"{\n"
"#if defined(USE_OREN_NAYAR) || defined(USE_TRIACE_OREN_NAYAR)\n"
"float gamma = dot( E, L ) - NE * NL;\n"
"float B = 2.22222 + 0.1 * shininess;\n"
"#if defined(USE_OREN_NAYAR)\n"
"float A = 1.0 - 1.0 / ( 2.0 + 0.33 * shininess );\n"
"gamma = clamp( gamma, 0.0, 1.0 );\n"
"#endif\n"
"#if defined(USE_TRIACE_OREN_NAYAR)\n"
"float A = 1.0 - 1.0 / ( 2.0 + 0.65 * shininess );\n"
"if( gamma >= 0.0 )\n"
"#endif\n"
"{\n"
"B = max( B * max( NL, NE ), EPSILON );\n"
"}\n"
"return diffuseAlbedo * ( A + gamma / B );\n"
"#else\n"
"return diffuseAlbedo;\n"
"#endif\n"
"}\n"
"vec3 EnvironmentBRDF( float gloss, float NE, vec3 specular )\n"
"{\n"
"#if 1\n"
"vec4 t = vec4( 1.0 / 0.96, 0.475, ( 0.0275 - 0.25 * 0.04 ) / 0.96, 0.25 ) * gloss;\n"
"t += vec4( 0.0, 0.0, ( 0.015 - 0.75 * 0.04 ) / 0.96, 0.75 );\n"
"float a0 = t.x * min( t.y, exp2( -9.28 * NE ) ) + t.z;\n"
"float a1 = t.w;\n"
"return clamp( a0 + specular * ( a1 - a0 ), 0.0, 1.0 );\n"
"#elif 0\n"
"return specular + CalcFresnel( NE ) * clamp( vec3( gloss ) - specular, 0.0, 1.0 );\n"
"#else\n"
"return mix( specular.rgb, vec3( 1.0 ), CalcFresnel( NE ) / ( 4.0 - 3.0 * gloss ) );\n"
"#endif\n"
"}\n"
"float CalcBlinn( float NH, float shininess )\n"
"{\n"
"#if defined(USE_BLINN) || defined(USE_BLINN_FRESNEL)\n"
"float norm = shininess * 0.125 + 1.0;\n"
"#elif defined(USE_MCAULEY)\n"
"float norm = shininess * 0.25 + 0.125;\n"
"#elif defined(USE_GOTANDA)\n"
"float norm = shininess * 0.124858 + 0.269182;\n"
"#elif defined(USE_LAZAROV)\n"
"float norm = shininess * 0.125 + 0.25;\n"
"#else\n"
"float norm = 1.0;\n"
"#endif\n"
"\n"
"#if 0\n"
"float a = shininess + 0.775;\n"
"return norm * exp( a * NH - a );\n"
"#else\n"
"return norm * pow( NH, shininess );\n"
"#endif\n"
"}\n"
"float CalcGGX( float NH, float gloss )\n"
"{\n"
"float a_sq = exp2( gloss * -13.0 + 1.0 );\n"
"float d = ( ( NH * NH ) * ( a_sq - 1.0 ) + 1.0 );\n"
"return a_sq / ( d * d );\n"
"}\n"
"float CalcFresnel( float EH )\n"
"{\n"
"#if 1\n"
"return exp2( -10.0 * EH );\n"
"#elif 0\n"
"return exp2( ( -5.55473 * EH - 6.98316 ) * EH );\n"
"#elif 0\n"
"float blend = 1.0 - EH;\n"
"float blend2 = blend * blend;\n"
"blend *= blend2 * blend2;\n"
"return blend;\n"
"#else\n"
"return pow( 1.0 - EH, 5.0 );\n"
"#endif\n"
"}\n"
"float CalcVisibility( float NH, float NL, float NE, float EH, float gloss )\n"
"{\n"
"#if defined(USE_GOTANDA)\n"
"return 1.0 / max( max( NL, NE ), EPSILON );\n"
"#elif defined(USE_LAZAROV)\n"
"float k = min( 1.0, gloss + 0.545 );\n"
"return 1.0 / ( k * ( EH * EH - 1.0 ) + 1.0 );\n"
"#elif defined(USE_GGX)\n"
"float roughness = exp2( gloss * -6.5 );\n"
"float k = roughness + 1.0;\n"
"k *= k * 0.125;\n"
"float k2 = 1.0 - k;\n"
"float invGeo1 = NL * k2 + k;\n"
"float invGeo2 = NE * k2 + k;\n"
"return 1.0 / ( invGeo1 * invGeo2 );\n"
"#else\n"
"return 1.0;\n"
"#endif\n"
"}\n"
"vec3 CalcSpecular( vec3 specular, float NH, float NL, float NE, float EH, float gloss, float shininess )\n"
"{\n"
"#if defined(USE_GGX)\n"
"float distrib = CalcGGX( NH, gloss );\n"
"#else\n"
"float distrib = CalcBlinn( NH, shininess );\n"
"#endif\n"
"#if defined(USE_BLINN)\n"
"vec3 fSpecular = specular;\n"
"#else\n"
"vec3 fSpecular = mix( specular, vec3( 1.0 ), CalcFresnel( EH ) );\n"
"#endif\n"
"float vis = CalcVisibility( NH, NL, NE, EH, gloss );\n"
"return fSpecular * ( distrib * vis );\n"
"}\n"
"float CalcLightAttenuation( float point, float normDist )\n"
"{\n"
"float attenuation = ( 0.5 * normDist - 1.5 ) * point + 1.0;\n"
"#if defined(NO_LIGHT_CLAMP)\n"
"attenuation = max( attenuation, 0.0 );\n"
"#else\n"
"attenuation = clamp( attenuation, 0.0, 1.0 );\n"
"#endif\n"
"return attenuation;\n"
"}\n"
"mat3 cotangent_frame( vec3 N, vec3 p, vec2 uv )\n"
"{\n"
"vec3 dp1 = dFdx( p );\n"
"vec3 dp2 = dFdy( p );\n"
"vec2 duv1 = dFdx( uv );\n"
"vec2 duv2 = dFdy( uv );\n"
"vec3 dp2perp = cross( dp2, N );\n"
"vec3 dp1perp = cross( N, dp1 );\n"
"vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n"
"vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n"
"float invmax = inversesqrt( max( dot( T, T ), dot( B, B ) ) );\n"
"return mat3( T * invmax, B * invmax, N );\n"
"}\n"
"void main()\n"
"{\n"
"vec3 viewDir, lightColor, ambientColor;\n"
"vec3 L, N, E, H;\n"
"float NL, NH, NE, EH, attenuation;\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"#if defined(USE_VERT_TANGENT_SPACE)\n"
"mat3 tangentToWorld = mat3( var_Tangent.xyz, var_Bitangent.xyz, var_Normal.xyz );\n"
"viewDir = vec3( var_Normal.w, var_Tangent.w, var_Bitangent.w );\n"
"#else\n"
"mat3 tangentToWorld = cotangent_frame( var_Normal, -var_ViewDir, var_TexCoords.xy );\n"
"viewDir = var_ViewDir;\n"
"#endif\n"
"E = normalize( viewDir );\n"
"L = var_LightDir.xyz;\n"
"#if defined(USE_DELUXEMAP)\n"
"L += ( texture2D( u_DeluxeMap, var_TexCoords.zw ).xyz - vec3( 0.5 ) ) * u_EnableTextures.y;\n"
"#endif\n"
"float sqrLightDist = dot( L, L );\n"
"#endif\n"
"#if defined(USE_LIGHTMAP)\n"
"vec4 lightmapColor = texture2D( u_LightMap, var_TexCoords.zw );\n"
"#if defined(RGBM_LIGHTMAP)\n"
"lightmapColor.rgb *= lightmapColor.a;\n"
"#endif\n"
"#endif\n"
"vec2 texCoords = var_TexCoords.xy;\n"
"#if defined(USE_PARALLAXMAP)\n"
"vec3 offsetDir = viewDir * tangentToWorld;\n"
"offsetDir.xy *= -u_NormalScale.a / offsetDir.z;\n"
"texCoords += offsetDir.xy * RayIntersectDisplaceMap( texCoords, offsetDir.xy, u_NormalMap );\n"
"#endif\n"
"vec4 diffuse = texture2D( u_DiffuseMap, texCoords );\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"#if defined(USE_LIGHTMAP)\n"
"lightColor = lightmapColor.rgb * var_Color.rgb;\n"
"ambientColor = vec3( 0.0 );\n"
"attenuation = 1.0;\n"
"#elif defined(USE_LIGHT_VECTOR)\n"
"lightColor = u_DirectedLight * var_Color.rgb;\n"
"ambientColor = u_AmbientLight * var_Color.rgb;\n"
"attenuation = CalcLightAttenuation( float( var_LightDir.w > 0.0 ), var_LightDir.w / sqrLightDist );\n"
"#elif defined(USE_LIGHT_VERTEX)\n"
"lightColor = var_Color.rgb;\n"
"ambientColor = vec3( 0.0 );\n"
"attenuation = 1.0;\n"
"#endif\n"
"#if defined(USE_NORMALMAP)\n"
"#if defined(SWIZZLE_NORMALMAP)\n"
"N.xy = texture2D( u_NormalMap, texCoords ).ag - vec2( 0.5 );\n"
"#else\n"
"N.xy = texture2D( u_NormalMap, texCoords ).rg - vec2( 0.5 );\n"
"#endif\n"
"N.xy *= u_NormalScale.xy;\n"
"N.z = sqrt( clamp( ( 0.25 - N.x * N.x ) - N.y * N.y, 0.0, 1.0 ) );\n"
"N = tangentToWorld * N;\n"
"#else\n"
"N = var_Normal.xyz;\n"
"#endif\n"
"N = normalize( N );\n"
"L /= sqrt( sqrLightDist );\n"
"#if defined(USE_SHADOWMAP) \n"
"vec2 shadowTex = gl_FragCoord.xy * r_FBufScale;\n"
"float shadowValue = texture2D( u_ShadowMap, shadowTex ).r;\n"
"shadowValue *= float( dot( var_Normal.xyz, var_PrimaryLightDir.xyz ) > 0.0 );\n"
"#if defined(SHADOWMAP_MODULATE)\n"
"vec3 shadowColor = u_PrimaryLightAmbient * lightColor;\n"
"#if 0\n"
"shadowValue = 1.0 + ( shadowValue - 1.0 ) * clamp( dot( L, var_PrimaryLightDir.xyz ), 0.0, 1.0 );\n"
"#endif\n"
"lightColor = mix( shadowColor, lightColor, shadowValue );\n"
"#endif\n"
"#endif\n"
"#if defined(r_lightGamma)\n"
"lightColor = pow( lightColor, vec3( r_lightGamma ) );\n"
"ambientColor = pow( ambientColor, vec3( r_lightGamma ) );\n"
"#endif\n"
"#if defined(USE_LIGHTMAP) || defined(USE_LIGHT_VERTEX)\n"
"ambientColor = lightColor;\n"
"float surfNL = clamp( dot( var_Normal.xyz, L ), 0.0, 1.0 );\n"
"lightColor /= max( surfNL, 0.25 );\n"
"ambientColor = clamp( ambientColor - lightColor * surfNL, 0.0, 1.0 );\n"
"#endif\n"
"vec3 reflectance;\n"
"NL = clamp( dot( N, L ), 0.0, 1.0 );\n"
"NE = clamp( dot( N, E ), 0.0, 1.0 );\n"
"#if defined(USE_SPECULARMAP)\n"
"vec4 specular = texture2D( u_SpecularMap, texCoords );\n"
"#else\n"
"vec4 specular = vec4( 1.0 );\n"
"#endif\n"
"specular *= u_SpecularScale;\n"
"#if defined(r_materialGamma)\n"
"diffuse.rgb = pow( diffuse.rgb, vec3( r_materialGamma ) );\n"
"specular.rgb = pow( specular.rgb, vec3( r_materialGamma ) );\n"
"#endif\n"
"float gloss = specular.a;\n"
"float shininess = exp2( gloss * 13.0 );\n"
"#if defined(SPECULAR_IS_METALLIC)\n"
"float metallic = specular.r;\n"
"specular.rgb = ( 0.96 * metallic ) * diffuse.rgb + vec3( 0.04 );\n"
"diffuse.rgb *= 1.0 - metallic;\n"
"#else\n"
"diffuse.rgb *= vec3( 1.0 ) - specular.rgb;\n"
"#endif\n"
"reflectance = CalcDiffuse( diffuse.rgb, N, L, E, NE, NL, shininess );\n"
"#if defined(r_deluxeSpecular) || defined(USE_LIGHT_VECTOR)\n"
"float adjGloss = gloss;\n"
"float adjShininess = shininess;\n"
"#if !defined(USE_LIGHT_VECTOR)\n"
"adjGloss *= r_deluxeSpecular;\n"
"adjShininess = exp2( adjGloss * 13.0 );\n"
"#endif\n"
"H = normalize( L + E );\n"
"EH = clamp( dot( E, H ), 0.0, 1.0 );\n"
"NH = clamp( dot( N, H ), 0.0, 1.0 );\n"
"#if !defined(USE_LIGHT_VECTOR)\n"
"reflectance += CalcSpecular( specular.rgb, NH, NL, NE, EH, adjGloss, adjShininess ) * r_deluxeSpecular;\n"
"#else\n"
"reflectance += CalcSpecular( specular.rgb, NH, NL, NE, EH, adjGloss, adjShininess );\n"
"#endif\n"
"#endif\n"
"gl_FragColor.rgb = lightColor   * reflectance * ( attenuation * NL );\n"
"#if 0\n"
"vec3 aSpecular = EnvironmentBRDF( gloss, NE, specular.rgb );\n"
"float hemiDiffuseUp = N.z * 0.5 + 0.5;\n"
"float hemiDiffuseDown = 1.0 - hemiDiffuseUp;\n"
"float hemiSpecularUp = mix( hemiDiffuseUp, float( N.z >= 0.0 ), gloss );\n"
"float hemiSpecularDown = 1.0 - hemiSpecularUp;\n"
"gl_FragColor.rgb += ambientColor * 0.75 * ( diffuse.rgb * hemiDiffuseUp + aSpecular * hemiSpecularUp );\n"
"gl_FragColor.rgb += ambientColor * 0.25 * ( diffuse.rgb * hemiDiffuseDown + aSpecular * hemiSpecularDown );\n"
"#else\n"
"gl_FragColor.rgb += ambientColor * ( diffuse.rgb + specular.rgb );\n"
"#endif\n"
"#if defined(USE_CUBEMAP)\n"
"reflectance = EnvironmentBRDF( gloss, NE, specular.rgb );\n"
"vec3 R = reflect( E, N );\n"
"vec3 parallax = u_CubeMapInfo.xyz + u_CubeMapInfo.w * viewDir;\n"
"vec3 cubeLightColor = textureCubeLod( u_CubeMap, R + parallax, 7.0 - gloss * 7.0 ).rgb * u_EnableTextures.w;\n"
"#if defined(r_framebufferGamma)\n"
"cubeLightColor = pow( cubeLightColor, vec3( r_framebufferGamma ) );\n"
"#endif\n"
"gl_FragColor.rgb += cubeLightColor * reflectance;\n"
"#endif\n"
"#if defined(USE_PRIMARY_LIGHT)\n"
"vec3 L2, H2;\n"
"float NL2, EH2, NH2;\n"
"L2 = var_PrimaryLightDir.xyz;\n"
"NL2 = clamp( dot( N, L2 ), 0.0, 1.0 );\n"
"H2 = normalize( L2 + E );\n"
"EH2 = clamp( dot( E, H2 ), 0.0, 1.0 );\n"
"NH2 = clamp( dot( N, H2 ), 0.0, 1.0 );\n"
"reflectance = CalcDiffuse( diffuse.rgb, N, L2, E, NE, NL2, shininess );\n"
"reflectance += CalcSpecular( specular.rgb, NH2, NL2, NE, EH2, gloss, shininess );\n"
"lightColor = u_PrimaryLightColor * var_Color.rgb;\n"
"#if defined(r_lightGamma)\n"
"lightColor = pow( lightColor, vec3( r_lightGamma ) );\n"
"#endif\n"
"#if defined(USE_SHADOWMAP)\n"
"lightColor *= shadowValue;\n"
"#endif\n"
"gl_FragColor.rgb += lightColor * reflectance * NL2;\n"
"#endif\n"
"#else\n"
"lightColor = var_Color.rgb;\n"
"#if defined(USE_LIGHTMAP) \n"
"lightColor *= lightmapColor.rgb;\n"
"#endif\n"
"#if defined(r_lightGamma)\n"
"lightColor = pow( lightColor, vec3( r_lightGamma ) );\n"
"#endif\n"
"#if defined(r_materialGamma)\n"
"diffuse.rgb = pow( diffuse.rgb, vec3( r_materialGamma ) );\n"
"#endif\n"
"gl_FragColor.rgb = diffuse.rgb * lightColor;\n"
"#endif\n"
"#if defined(r_framebufferGamma)\n"
"gl_FragColor.rgb = pow( gl_FragColor.rgb, vec3( 1.0 / r_framebufferGamma ) );\n"
"#endif\n"
"gl_FragColor.a = diffuse.a * var_Color.a;\n"
"}\n";

const char *fallbackShader_pshadow_vp =
"attribute vec3 attr_Position;\n"
"attribute vec3 attr_Normal;\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"varying vec3 var_Position;\n"
"varying vec3 var_Normal;\n"
"void main()\n"
"{\n"
"gl_Position = u_ModelViewProjectionMatrix * vec4( attr_Position, 1.0 );\n"
"var_Position = attr_Position;\n"
"var_Normal = attr_Normal;\n"
"}\n";

const char *fallbackShader_pshadow_fp =
"uniform sampler2D u_ShadowMap;\n"
"uniform vec3 u_LightForward;\n"
"uniform vec3 u_LightUp;\n"
"uniform vec3 u_LightRight;\n"
"uniform vec4 u_LightOrigin;\n"
"uniform float u_LightRadius;\n"
"varying vec3 var_Position;\n"
"varying vec3 var_Normal;\n"
"float sampleDistMap( sampler2D texMap, vec2 uv, float scale )\n"
"{\n"
"vec3 distv = texture2D( texMap, uv ).xyz;\n"
"return dot( distv, vec3( 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 ) ) * scale;\n"
"}\n"
"void main()\n"
"{\n"
"vec3 lightToPos = var_Position - u_LightOrigin.xyz;\n"
"vec2 st = vec2( -dot( u_LightRight, lightToPos ), dot( u_LightUp, lightToPos ) );\n"
"float fade = length( st );\n"
"#if defined(USE_DISCARD)\n"
"if( fade >= 1.0 )\n"
"{\n"
"discard;\n"
"}\n"
"#endif\n"
"fade = clamp( 8.0 - fade * 8.0, 0.0, 1.0 );\n"
"st = st * 0.5 + vec2( 0.5 );\n"
"#if defined(USE_SOLID_PSHADOWS)\n"
"float intensity = max( sign( u_LightRadius - length( lightToPos ) ), 0.0 );\n"
"#else\n"
"float intensity = clamp( ( 1.0 - dot( lightToPos, lightToPos ) / ( u_LightRadius * u_LightRadius ) ) * 2.0, 0.0, 1.0 );\n"
"#endif\n"
"float lightDist = length( lightToPos );\n"
"float dist;\n"
"#if defined(USE_DISCARD)\n"
"if( dot( u_LightForward, lightToPos ) <= 0.0 )\n"
"{\n"
"discard;\n"
"}\n"
"if( dot( var_Normal, lightToPos ) > 0.0 )\n"
"{\n"
"discard;\n"
"}\n"
"#else\n"
"intensity *= max( sign( dot( u_LightForward, lightToPos ) ), 0.0 );\n"
"intensity *= max( sign( -dot( var_Normal, lightToPos ) ), 0.0 );\n"
"#endif\n"
"intensity *= fade;\n"
"#if defined(USE_PCF)\n"
"float part;\n"
"dist = sampleDistMap( u_ShadowMap, st + vec2( -1.0 / 512.0, -1.0 / 512.0 ), u_LightRadius );\n"
"part = max( sign( lightDist - dist ), 0.0 );\n"
"dist = sampleDistMap( u_ShadowMap, st + vec2( 1.0 / 512.0, -1.0 / 512.0 ), u_LightRadius );\n"
"part += max( sign( lightDist - dist ), 0.0 );\n"
"dist = sampleDistMap( u_ShadowMap, st + vec2( -1.0 / 512.0, 1.0 / 512.0 ), u_LightRadius );\n"
"part += max( sign( lightDist - dist ), 0.0 );\n"
"dist = sampleDistMap( u_ShadowMap, st + vec2( 1.0 / 512.0, 1.0 / 512.0 ), u_LightRadius );\n"
"part += max( sign( lightDist - dist ), 0.0 );\n"
"#if defined(USE_DISCARD)\n"
"if( part <= 0.0 )\n"
"{\n"
"discard;\n"
"}\n"
"#endif\n"
"intensity *= part * 0.25;\n"
"#else\n"
"dist = sampleDistMap( u_ShadowMap, st, u_LightRadius );\n"
"#if defined(USE_DISCARD)\n"
"if( lightDist - dist <= 0.0 )\n"
"{\n"
"discard;\n"
"}\n"
"#endif\n"
"intensity *= max( sign( lightDist - dist ), 0.0 );\n"
"#endif\n"
"gl_FragColor.rgb = vec3( 0 );\n"
"gl_FragColor.a = clamp( intensity, 0.0, 0.75 );\n"
"}\n";

const char *fallbackShader_shadowfill_vp =
"attribute vec3  attr_Position;\n"
"attribute vec3  attr_Normal;\n"
"attribute vec4  attr_TexCoord0;\n"
"//#if defined(USE_VERTEX_ANIMATION)\n"
"attribute vec3  attr_Position2;\n"
"attribute vec3  attr_Normal2;\n"
"//#endif\n"
"//#if defined(USE_DEFORM_VERTEXES)\n"
"uniform int     u_DeformGen;\n"
"uniform float    u_DeformParams[ 5 ];\n"
"//#endif\n"
"uniform float   u_Time;\n"
"uniform mat4    u_ModelViewProjectionMatrix;\n"
"uniform mat4   u_ModelMatrix;\n"
"//#if defined(USE_VERTEX_ANIMATION)\n"
"uniform float   u_VertexLerp;\n"
"//#endif\n"
"varying vec3    var_Position;\n"
"vec3 DeformPosition( const vec3 pos, const vec3 normal, const vec2 st )\n"
"{\n"
"if( u_DeformGen == 0 )\n"
"{\n"
"return pos;\n"
"}\n"
"float base = u_DeformParams[ 0 ];\n"
"float amplitude = u_DeformParams[ 1 ];\n"
"float phase = u_DeformParams[ 2 ];\n"
"float frequency = u_DeformParams[ 3 ];\n"
"float spread = u_DeformParams[ 4 ];\n"
"if( u_DeformGen == DGEN_BULGE )\n"
"{\n"
"phase *= st.x;\n"
"}\n"
"else // if (u_DeformGen <= DGEN_WAVE_INVERSE_SAWTOOTH)\n"
"{\n"
"phase += dot( pos.xyz, vec3( spread ) );\n"
"}\n"
"float value = phase + ( u_Time * frequency );\n"
"float func;\n"
"if( u_DeformGen == DGEN_WAVE_SIN )\n"
"{\n"
"func = sin( value * 2.0 * M_PI );\n"
"}\n"
"else if( u_DeformGen == DGEN_WAVE_SQUARE )\n"
"{\n"
"func = sign( 0.5 - fract( value ) );\n"
"}\n"
"else if( u_DeformGen == DGEN_WAVE_TRIANGLE )\n"
"{\n"
"func = abs( fract( value + 0.75 ) - 0.5 ) * 4.0 - 1.0;\n"
"}\n"
"else if( u_DeformGen == DGEN_WAVE_SAWTOOTH )\n"
"{\n"
"func = fract( value );\n"
"}\n"
"else if( u_DeformGen == DGEN_WAVE_INVERSE_SAWTOOTH )\n"
"{\n"
"func = ( 1.0 - fract( value ) );\n"
"}\n"
"else // if (u_DeformGen == DGEN_BULGE)\n"
"{\n"
"func = sin( value );\n"
"}\n"
"return pos + normal * ( base + func * amplitude );\n"
"}\n"
"void main()\n"
"{\n"
"vec3 position = mix( attr_Position, attr_Position2, u_VertexLerp );\n"
"vec3 normal = mix( attr_Normal, attr_Normal2, u_VertexLerp );\n"
"position = DeformPosition( position, normal, attr_TexCoord0.st );\n"
"gl_Position = u_ModelViewProjectionMatrix * vec4( position, 1.0 );\n"
"var_Position = ( u_ModelMatrix * vec4( position, 1.0 ) ).xyz;\n"
"}\n";

const char *fallbackShader_shadowfill_fp =
"uniform vec4  u_LightOrigin;\n"
"uniform float u_LightRadius;\n"
"varying vec3  var_Position;\n"
"void main()\n"
"{\n"
"#if defined(USE_DEPTH)\n"
"float depth = length( u_LightOrigin.xyz - var_Position ) / u_LightRadius;\n"
"#if 0\n"
"const vec4 bitSh = vec4( 256 * 256 * 256, 256 * 256, 256, 1 );\n"
"const vec4 bitMsk = vec4( 0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n"
"vec4 comp;\n"
"comp = depth * bitSh;\n"
"comp.xyz = fract( comp.xyz );\n"
"comp -= comp.xxyz * bitMsk;\n"
"gl_FragColor = comp;\n"
"#endif\n"
"#if 1\n"
"const vec3 bitSh = vec3( 256 * 256, 256, 1 );\n"
"const vec3 bitMsk = vec3( 0, 1.0 / 256.0, 1.0 / 256.0 );\n"
"vec3 comp;\n"
"comp = depth * bitSh;\n"
"comp.xy = fract( comp.xy );\n"
"comp -= comp.xxy * bitMsk;\n"
"gl_FragColor = vec4( comp, 1.0 );\n"
"#endif\n"
"#if 0\n"
"gl_FragColor = vec4( depth, depth, depth, 1 );\n"
"#endif\n"
"#else\n"
"gl_FragColor = vec4( 0, 0, 0, 1 );\n"
"#endif\n"
"}\n";

const char *fallbackShader_shadowmask_vp =
"attribute vec4 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"uniform vec3 u_ViewForward;\n"
"uniform vec3 u_ViewLeft;\n"
"uniform vec3 u_ViewUp;\n"
"uniform vec4 u_ViewInfo;\n"
"varying vec2 var_DepthTex;\n"
"varying vec3 var_ViewDir;\n"
"void main()\n"
"{\n"
"gl_Position = attr_Position;\n"
"vec2 screenCoords = gl_Position.xy / gl_Position.w;\n"
"var_DepthTex = attr_TexCoord0.xy;\n"
"var_ViewDir = u_ViewForward + u_ViewLeft * -screenCoords.x + u_ViewUp * screenCoords.y;\n"
"}\n";

const char *fallbackShader_shadowmask_fp =
"uniform sampler2D u_ScreenDepthMap;\n"
"uniform sampler2DShadow u_ShadowMap;\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"uniform sampler2DShadow u_ShadowMap2;\n"
"uniform sampler2DShadow u_ShadowMap3;\n"
"uniform sampler2DShadow u_ShadowMap4;\n"
"#endif\n"
"uniform mat4      u_ShadowMvp;\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"uniform mat4      u_ShadowMvp2;\n"
"uniform mat4      u_ShadowMvp3;\n"
"uniform mat4      u_ShadowMvp4;\n"
"#endif\n"
"uniform vec3   u_ViewOrigin;\n"
"uniform vec4   u_ViewInfo;\n"
"varying vec2   var_DepthTex;\n"
"varying vec3   var_ViewDir;\n"
"#define DEPTH_MAX_ERROR 0.000000059604644775390625\n"
"float random( const vec2 p )\n"
"{\n"
"const vec2 r = vec2(\n"
"23.1406926327792690,\n"
"2.6651441426902251 );\n"
"return mod( 123456789., 1e-7 + 256. * dot( p, r ) );\n"
"}\n"
"float PCF( const sampler2DShadow shadowmap, const vec2 st, const float dist )\n"
"{\n"
"float mult;\n"
"float scale = 2.0 / r_shadowMapSize;\n"
"#if 0\n"
"vec2 offset = vec2( greaterThan( fract( var_DepthTex.xy * r_FBufScale * 0.5 ), vec2( 0.25 ) ) );\n"
"offset.y += offset.x;\n"
"if( offset.y > 1.1 ) offset.y = 0.0;\n"
"mult = shadow2D( shadowmap, vec3( st + ( offset + vec2( -1.5, 0.5 ) ) * scale, dist ) ).r\n"
"+ shadow2D( shadowmap, vec3( st + ( offset + vec2( 0.5, 0.5 ) ) * scale, dist ) ).r\n"
"+ shadow2D( shadowmap, vec3( st + ( offset + vec2( -1.5, -1.5 ) ) * scale, dist ) ).r\n"
"+ shadow2D( shadowmap, vec3( st + ( offset + vec2( 0.5, -1.5 ) ) * scale, dist ) ).r;\n"
"mult *= 0.25;\n"
"#endif\n"
"#if defined(USE_SHADOW_FILTER)\n"
"float r = random( var_DepthTex.xy );\n"
"float sinr = sin( r ) * scale;\n"
"float cosr = cos( r ) * scale;\n"
"mat2 rmat = mat2( cosr, sinr, -sinr, cosr );\n"
"mult = shadow2D( shadowmap, vec3( st + rmat * vec2( -0.7055767, 0.196515 ), dist ) ).r;\n"
"mult += shadow2D( shadowmap, vec3( st + rmat * vec2( 0.3524343, -0.7791386 ), dist ) ).r;\n"
"mult += shadow2D( shadowmap, vec3( st + rmat * vec2( 0.2391056, 0.9189604 ), dist ) ).r;\n"
"#if defined(USE_SHADOW_FILTER2)\n"
"mult += shadow2D( shadowmap, vec3( st + rmat * vec2( -0.07580382, -0.09224417 ), dist ) ).r;\n"
"mult += shadow2D( shadowmap, vec3( st + rmat * vec2( 0.5784913, -0.002528916 ), dist ) ).r;\n"
"mult += shadow2D( shadowmap, vec3( st + rmat * vec2( 0.192888, 0.4064181 ), dist ) ).r;\n"
"mult += shadow2D( shadowmap, vec3( st + rmat * vec2( -0.6335801, -0.5247476 ), dist ) ).r;\n"
"mult += shadow2D( shadowmap, vec3( st + rmat * vec2( -0.5579782, 0.7491854 ), dist ) ).r;\n"
"mult += shadow2D( shadowmap, vec3( st + rmat * vec2( 0.7320465, 0.6317794 ), dist ) ).r;\n"
"mult *= 0.11111;\n"
"#else\n"
"mult *= 0.33333;\n"
"#endif\n"
"#else\n"
"mult = shadow2D( shadowmap, vec3( st, dist ) ).r;\n"
"#endif\n"
"return mult;\n"
"}\n"
"float getLinearDepth( sampler2D depthMap, vec2 tex, float zFarDivZNear )\n"
"{\n"
"float sampleZDivW = texture2D( depthMap, tex ).r - DEPTH_MAX_ERROR;\n"
"return 1.0 / mix( zFarDivZNear, 1.0, sampleZDivW );\n"
"}\n"
"void main()\n"
"{\n"
"float result;\n"
"float depth = getLinearDepth( u_ScreenDepthMap, var_DepthTex, u_ViewInfo.x );\n"
"vec4 biasPos = vec4( u_ViewOrigin + var_ViewDir * ( depth - 0.5 / u_ViewInfo.x ), 1.0 );\n"
"vec4 shadowpos = u_ShadowMvp * biasPos;\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"if( all( lessThan( abs( shadowpos.xyz ), vec3( abs( shadowpos.w ) ) ) ) )\n"
"{\n"
"#endif\n"
"shadowpos.xyz = shadowpos.xyz * ( 0.5 / shadowpos.w ) + vec3( 0.5 );\n"
"result = PCF( u_ShadowMap, shadowpos.xy, shadowpos.z );\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"}\n"
"else\n"
"{\n"
"shadowpos = u_ShadowMvp2 * biasPos;\n"
"if( all( lessThan( abs( shadowpos.xyz ), vec3( abs( shadowpos.w ) ) ) ) )\n"
"{\n"
"shadowpos.xyz = shadowpos.xyz * ( 0.5 / shadowpos.w ) + vec3( 0.5 );\n"
"result = PCF( u_ShadowMap2, shadowpos.xy, shadowpos.z );\n"
"}\n"
"else\n"
"{\n"
"shadowpos = u_ShadowMvp3 * biasPos;\n"
"if( all( lessThan( abs( shadowpos.xyz ), vec3( abs( shadowpos.w ) ) ) ) )\n"
"{\n"
"shadowpos.xyz = shadowpos.xyz * ( 0.5 / shadowpos.w ) + vec3( 0.5 );\n"
"result = PCF( u_ShadowMap3, shadowpos.xy, shadowpos.z );\n"
"}\n"
"else\n"
"{\n"
"shadowpos = u_ShadowMvp4 * biasPos;\n"
"shadowpos.xyz = shadowpos.xyz * ( 0.5 / shadowpos.w ) + vec3( 0.5 );\n"
"result = PCF( u_ShadowMap4, shadowpos.xy, shadowpos.z );\n"
"}\n"
"}\n"
"}\n"
"#endif\n"
"gl_FragColor = vec4( vec3( result ), 1.0 );\n"
"}\n";

const char *fallbackShader_ssao_vp =
"attribute vec4 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"varying vec2 var_ScreenTex;\n"
"void main()\n"
"{\n"
"gl_Position = attr_Position;\n"
"var_ScreenTex = attr_TexCoord0.xy;\n"
"}\n";

const char *fallbackShader_ssao_fp =
"uniform sampler2D u_ScreenDepthMap;\n"
"uniform vec4   u_ViewInfo;\n"
"varying vec2   var_ScreenTex;\n"
"vec2 poissonDisc[ 9 ] = vec2[ 9 ](\n"
"vec2( -0.7055767, 0.196515 ), vec2( 0.3524343, -0.7791386 ),\n"
"vec2( 0.2391056, 0.9189604 ), vec2( -0.07580382, -0.09224417 ),\n"
"vec2( 0.5784913, -0.002528916 ), vec2( 0.192888, 0.4064181 ),\n"
"vec2( -0.6335801, -0.5247476 ), vec2( -0.5579782, 0.7491854 ),\n"
"vec2( 0.7320465, 0.6317794 )\n"
");\n"
"float random( const vec2 p )\n"
"{\n"
"const vec2 r = vec2(\n"
"23.1406926327792690,\n"
"2.6651441426902251 );\n"
"return mod( 123456789., 1e-7 + 256. * dot( p, r ) );\n"
"}\n"
"mat2 randomRotation( const vec2 p )\n"
"{\n"
"float r = random( p );\n"
"float sinr = sin( r );\n"
"float cosr = cos( r );\n"
"return mat2( cosr, sinr, -sinr, cosr );\n"
"}\n"
"float getLinearDepth( sampler2D depthMap, const vec2 tex, const float zFarDivZNear )\n"
"{\n"
"float sampleZDivW = texture2D( depthMap, tex ).r;\n"
"return 1.0 / mix( zFarDivZNear, 1.0, sampleZDivW );\n"
"}\n"
"float ambientOcclusion( sampler2D depthMap, const vec2 tex, const float zFarDivZNear, const float zFar )\n"
"{\n"
"float result = 0;\n"
"float sampleZ = zFar * getLinearDepth( depthMap, tex, zFarDivZNear );\n"
"vec2 expectedSlope = vec2( dFdx( sampleZ ), dFdy( sampleZ ) ) / vec2( dFdx( tex.x ), dFdy( tex.y ) );\n"
"if( length( expectedSlope ) > 5000.0 )\n"
"return 1.0;\n"
"vec2 offsetScale = vec2( 3.0 / sampleZ );\n"
"mat2 rmat = randomRotation( tex );\n"
"int i;\n"
"for( i = 0; i < 3; i++ )\n"
"{\n"
"vec2 offset = rmat * poissonDisc[ i ] * offsetScale;\n"
"float sampleZ2 = zFar * getLinearDepth( depthMap, tex + offset, zFarDivZNear );\n"
"if( abs( sampleZ - sampleZ2 ) > 20.0 )\n"
"result += 1.0;\n"
"else\n"
"{\n"
"float expectedZ = sampleZ + dot( expectedSlope, offset );\n"
"result += step( expectedZ - 1.0, sampleZ2 );\n"
"}\n"
"}\n"
"result *= 0.33333;\n"
"return result;\n"
"}\n"
"void main()\n"
"{\n"
"float result = ambientOcclusion( u_ScreenDepthMap, var_ScreenTex, u_ViewInfo.x, u_ViewInfo.y );\n"
"gl_FragColor = vec4( vec3( result ), 1.0 );\n"
"}\n";

const char *fallbackShader_texturecolor_vp =
"attribute vec3 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"varying vec2 var_Tex1;\n"
"void main()\n"
"{\n"
"gl_Position = u_ModelViewProjectionMatrix * vec4( attr_Position, 1.0 );\n"
"var_Tex1 = attr_TexCoord0.st;\n"
"}\n";

const char *fallbackShader_texturecolor_fp =
"uniform sampler2D u_DiffuseMap;\n"
"uniform vec4 u_Color;\n"
"varying vec2 var_Tex1;\n"
"void main()\n"
"{\n"
"gl_FragColor = texture2D( u_DiffuseMap, var_Tex1 ) * u_Color;\n"
"}\n";

const char *fallbackShader_tonemap_vp =
"attribute vec3 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"uniform vec3 u_ToneMinAvgMaxLinear;\n"
"varying vec2 var_TexCoords;\n"
"varying float var_InvWhite;\n"
"float FilmicTonemap( float x )\n"
"{\n"
"const float SS = 0.22;\n"
"const float LS = 0.30;\n"
"const float LA = 0.10;\n"
"const float TS = 0.20;\n"
"const float TAN = 0.01;\n"
"const float TAD = 0.30;\n"
"return ( ( x*( SS*x + LA*LS ) + TS*TAN ) / ( x*( SS*x + LS ) + TS*TAD ) ) - TAN / TAD;\n"
"}\n"
"void main()\n"
"{\n"
"gl_Position = u_ModelViewProjectionMatrix * vec4( attr_Position, 1.0 );\n"
"var_TexCoords = attr_TexCoord0.st;\n"
"var_InvWhite = 1.0 / FilmicTonemap( u_ToneMinAvgMaxLinear.z - u_ToneMinAvgMaxLinear.x );\n"
"}\n";

const char *fallbackShader_tonemap_fp =
"uniform sampler2D u_TextureMap;\n"
"uniform sampler2D u_LevelsMap;\n"
"uniform vec4 u_Color;\n"
"uniform vec2 u_AutoExposureMinMax;\n"
"uniform vec3 u_ToneMinAvgMaxLinear;\n"
"varying vec2 var_TexCoords;\n"
"varying float var_InvWhite;\n"
"const vec3  LUMINANCE_VECTOR = vec3( 0.2125, 0.7154, 0.0721 );\n"
"float FilmicTonemap( float x )\n"
"{\n"
"const float SS = 0.22;\n"
"const float LS = 0.30;\n"
"const float LA = 0.10;\n"
"const float TS = 0.20;\n"
"const float TAN = 0.01;\n"
"const float TAD = 0.30;\n"
"return ( ( x*( SS*x + LA*LS ) + TS*TAN ) / ( x*( SS*x + LS ) + TS*TAD ) ) - TAN / TAD;\n"
"}\n"
"void main()\n"
"{\n"
"vec4 color = texture2D( u_TextureMap, var_TexCoords ) * u_Color;\n"
"#if defined(r_framebufferGamma)\n"
"color.rgb = pow( color.rgb, vec3( r_framebufferGamma ) );\n"
"#endif\n"
"vec3 minAvgMax = texture2D( u_LevelsMap, var_TexCoords ).rgb;\n"
"vec3 logMinAvgMaxLum = clamp( minAvgMax * 20.0 - 10.0, -u_AutoExposureMinMax.y, -u_AutoExposureMinMax.x );\n"
"float invAvgLum = u_ToneMinAvgMaxLinear.y * exp2( -logMinAvgMaxLum.y );\n"
"color.rgb = color.rgb * invAvgLum - u_ToneMinAvgMaxLinear.xxx;\n"
"color.rgb = max( vec3( 0.0 ), color.rgb );\n"
"color.r = FilmicTonemap( color.r );\n"
"color.g = FilmicTonemap( color.g );\n"
"color.b = FilmicTonemap( color.b );\n"
"color.rgb = clamp( color.rgb * var_InvWhite, 0.0, 1.0 );\n"
"#if defined(r_tonemapGamma)\n"
"color.rgb = pow( color.rgb, vec3( 1.0 / r_tonemapGamma ) );\n"
"#endif\n"
"gl_FragColor = color;\n"
"}\n";
