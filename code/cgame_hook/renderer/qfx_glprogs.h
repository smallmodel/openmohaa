/***************************************************************************
* Copyright (C) 2012, Chain Studios.
* 
* This file is part of QeffectsGL source code.
* 
* QeffectsGL source code is free software; you can redistribute it 
* and/or modify it under the terms of the GNU General Public License 
* as published by the Free Software Foundation; either version 2 of 
* the License, or (at your option) any later version.
* 
* QeffectsGL source code is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied 
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
* See the GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software 
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
***************************************************************************/
#ifndef QFX_GLPROGS_H
#define QFX_GLPROGS_H

static const char g_szVertexShader_DOFDepth[] = 
"void main(void)\n"
"{\n"
"gl_TexCoord[0] = gl_MultiTexCoord0;\n"
"gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"}\n";

static const char g_szFragmentShader_DOFDepth[] = 
"#extension GL_ARB_texture_rectangle : enable\n"
"uniform vec4 Local0;\n"
"uniform sampler2DRect Texture0;\n"
"float read_depth( vec2 coord )\n"
"{\n"
"return Local0.x / (Local0.y + Local0.x - texture2DRect( Texture0, coord ).r * Local0.y);\n"
"}\n"
"void main(void)\n"
"{\n"
"gl_FragColor.rgb = read_depth( gl_TexCoord[0].xy );\n"
"gl_FragColor.a	= 1.0;\n"
"}\n";

static const char g_szVertexShader_DOFBlur[] = 
"uniform vec4 Local0;\n"
"void main(void)\n"
"{\n"
"gl_TexCoord[0] = gl_MultiTexCoord0 + Local0;\n"
"gl_TexCoord[1] = gl_MultiTexCoord0 + Local0 * 2.0;\n"
"gl_TexCoord[2] = gl_MultiTexCoord0 - Local0;\n"
"gl_TexCoord[3] = gl_MultiTexCoord0 - Local0 * 2.0;\n"
"gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"}\n";

static const char g_szFragmentShader_DOFBlur[] = 
"#extension GL_ARB_texture_rectangle : enable\n"
"uniform sampler2DRect Texture0;\n"
"void main(void)\n"
"{\n"
"vec3 col1 = texture2DRect(Texture0, gl_TexCoord[0].xy).rgb;\n"
"vec3 col2 = texture2DRect(Texture0, gl_TexCoord[1].xy).rgb;\n"
"vec3 col3 = texture2DRect(Texture0, gl_TexCoord[2].xy).rgb;\n"
"vec3 col4 = texture2DRect(Texture0, gl_TexCoord[3].xy).rgb;\n"
"gl_FragColor.rgb = (col1 + col2 + col3 + col4) / 4.0;\n"
"gl_FragColor.a	= 1.0;\n"
"}\n";

static const char g_szVertexShader_DOFRender[] = 
"void main(void)\n"
"{\n"
"gl_TexCoord[0] = gl_MultiTexCoord0.xyxy * vec4( 1.0, 1.0, 0.5, 0.5 );\n"
"gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"}\n";

static const char g_szFragmentShader_DOFRender[] = 
"#extension GL_ARB_texture_rectangle : enable\n"
"uniform vec4 Local0;\n"
"uniform sampler2DRect Texture0;\n"
"uniform sampler2DRect Texture1;\n"
"uniform sampler2DRect Texture2;\n"
"void main(void)\n"
"{\n"
"float ratio;\n"
"vec3 colNormal = texture2DRect(Texture0, gl_TexCoord[0].xy).rgb;\n"
"vec3 colBlur = texture2DRect(Texture1, gl_TexCoord[0].zw).rgb;\n"
"float depth = texture2DRect(Texture2, gl_TexCoord[0].zw).r;\n"
"if ( depth < Local0.x || depth == 1.0 ) ratio = 0.0;\n"
"else ratio = clamp( abs(depth - Local0.y) * Local0.z, 0.0, 1.0 );\n"
"gl_FragColor.rgb = mix( colNormal, colBlur, ratio * pow( depth, 0.25 ) );\n"
"gl_FragColor.a	= 1.0;\n"
"}\n";

static const char g_szVertexShader_Emboss[] = 
"void main(void)\n"
"{\n"
"gl_TexCoord[0] = gl_MultiTexCoord0;\n"
"gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"}\n";

static const char g_szFragmentShader_Emboss[] = 
"#extension GL_ARB_texture_rectangle : enable\n"
"uniform sampler2DRect Texture0;\n"
"uniform vec4 Local0;\n"
"void main(void)\n"
"{\n"
"vec3 col1 = texture2DRect(Texture0, gl_TexCoord[0].xy - vec2( 1.0, 1.0 )).rgb;\n"
"vec3 col2 = texture2DRect(Texture0, gl_TexCoord[0].xy).rgb;\n"
"vec3 col3 = texture2DRect(Texture0, gl_TexCoord[0].xy + vec2( 1.0, 1.0 )).rgb;\n"
"vec3 colEmboss = col1 * 2.0 - col2 - col3;\n"
"float colDot = max( 0.0, dot( colEmboss, vec3( 0.333, 0.333, 0.333 ) ) ) * Local0.x;\n"
"vec3 colFinal = col2 - vec3( colDot ) ;\n"
"float luminance = dot( col2, vec3( 0.6, 0.2, 0.2 ) );\n"
"gl_FragColor.rgb = mix( colFinal, col2, luminance * luminance );\n"
"gl_FragColor.a	= 1.0;\n"
"}\n";

static const char g_szVertexShader_HSL[] = 
"void main(void)\n"
"{\n"
"gl_TexCoord[0] = gl_MultiTexCoord0;\n"
"gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"}\n";

// This nice HSL color correction shader code was taken from:
// http://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/
// It produces the same result as Photoshop

// http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness
static const char g_szFragmentShader_HSL[] =
"#version 130\n"
"#extension GL_ARB_texture_rectangle : enable\n"
"precision mediump float;\n"
"varying vec2 vTextureCoord;\n"
"uniform vec4 Local0;\n"
"uniform vec4 Local1;\n"
"uniform vec4 Local2;\n"
"uniform vec4 Local3;\n"
"uniform sampler2DRect Texture0;\n"
"vec3 rgb2hsv( vec3 c )\n"
"{\n"
"	vec4 K = vec4( 0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0 );\n"
"	vec4 p = mix( vec4( c.bg, K.wz ), vec4( c.gb, K.xy ), step( c.b, c.g ) );\n"
"	vec4 q = mix( vec4( p.xyw, c.r ), vec4( c.r, p.yzx ), step( p.x, c.r ) );\n"
"	float d = q.x - min( q.w, q.y );\n"
"	float e = 1.0e-10;\n"
"	return vec3( abs( q.z + ( q.w - q.y ) / ( 6.0 * d + e ) ), d / ( q.x + e ), q.x );\n"
"}\n"
"vec3 hsv2rgb( vec3 c )\n"
"{\n"
"	vec4 K = vec4( 1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0 );\n"
"	vec3 p = abs( fract( c.xxx + K.xyz ) * 6.0 - K.www );\n"
"	return c.z * mix( K.xxx, clamp( p - K.xxx, 0.0, 1.0 ), c.y );\n"
"}\n"
"vec4 processHSV( vec4 textureColor, vec4 hsv )\n"
"{\n"
"vec3 fragRGB = textureColor.rgb;\n"
"vec3 fragHSV = rgb2hsv( fragRGB );\n"
"hsv.z = 0.9999;\n"
"float h = hsv.x / 360.0;\n"
"fragHSV.x *= h;\n"
"fragHSV.yz *= hsv.yz;\n"
"fragHSV.x = mod( fragHSV.x, 1.0 );\n"
"fragHSV.y = mod( fragHSV.y, 1.0 );\n"
"fragHSV.z = mod( fragHSV.z, 1.0 );\n"
"fragRGB = hsv2rgb( fragHSV );\n"
"return vec4( hsv2rgb( fragHSV ), textureColor.w );\n"
"}\n"
"void main() {\n"
"vec4 col = texture2DRect( Texture0, gl_TexCoord[0].xy );\n"
"vec4 rgb_dark = processHSV( col, Local0 );\n"
"vec4 rgb_mid = processHSV( col, Local1 );\n"
"vec4 rgb_light = processHSV( col, Local2 );\n"
"if( col.r >= Local3.x && col.r <= Local3.y ) { gl_FragColor.r = rgb_mid.r; } else if( col.r < Local3.x ) { gl_FragColor.r = rgb_dark.r; } else if( col.r > Local3.y ) { gl_FragColor.r = rgb_light.r; }\n"
"if( col.g >= Local3.x && col.g <= Local3.y ) { gl_FragColor.g = rgb_mid.g; } else if( col.g < Local3.x ) { gl_FragColor.g = rgb_dark.g; } else if( col.g > Local3.y ) { gl_FragColor.g = rgb_light.g; }\n"
"if( col.b >= Local3.x && col.b <= Local3.y ) { gl_FragColor.b = rgb_mid.b; } else if( col.b < Local3.x ) { gl_FragColor.b = rgb_dark.b; } else if( col.b > Local3.y ) { gl_FragColor.b = rgb_light.b; }\n"
"}\n";
/*"uniform sampler2DRect Texture0;\n"
"uniform vec4 Local0;\n"
"uniform vec4 Local1;\n"
"uniform vec4 Local2;\n"
"uniform vec4 Local3;\n"
"vec3 rgb_to_hsl( const vec3 color )\n"
"{\n"
"vec3 hsl;\n"
"float fmin = min(min(color.r, color.g), color.b);\n"
"float fmax = max(max(color.r, color.g), color.b);\n"
"float delta = fmax - fmin;\n"
"hsl.z = (fmax + fmin) / 2.0;\n"
"if (delta == 0.0) {\n"
"hsl.x = 0.0;\n"
"hsl.y = 0.0;\n"
"} else {\n"
"if (hsl.z < 0.5) hsl.y = delta / (fmax + fmin);\n"
"else hsl.y = delta / (2.0 - fmax - fmin);\n"
"float deltaR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\n"
"float deltaG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\n"
"float deltaB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n"
"if (color.r == fmax ) hsl.x = deltaB - deltaG;\n"
"else if (color.g == fmax) hsl.x = (1.0 / 3.0) + deltaR - deltaB;\n"
"else if (color.b == fmax) hsl.x = (2.0 / 3.0) + deltaG - deltaR;\n"
"if (hsl.x < 0.0) hsl.x += 1.0;\n"
"else if (hsl.x > 1.0) hsl.x -= 1.0;\n"
"}\n"
"return hsl;\n"
"}\n"
"float hue_to_rgb( float f1, float f2, float hue )\n"
"{\n"
"if (hue < 0.0) hue += 1.0;\n"
"else if (hue > 1.0) hue -= 1.0;\n"
"float res;\n"
"if ((6.0 * hue) < 1.0) res = f1 + (f2 - f1) * 6.0 * hue;\n"
"else if ((2.0 * hue) < 1.0) res = f2;\n"
"else if ((3.0 * hue) < 2.0) res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n"
"else res = f1;\n"
"return res;\n"
"}\n"
"vec3 hsl_to_rgb( vec3 hsl )\n"
"{\n"
"vec3 rgb;\n"
"if (hsl.y == 0.0) rgb = vec3(hsl.z);\n"
"else {\n"
"float f2;\n"
"if (hsl.z < 0.5) f2 = hsl.z * (1.0 + hsl.y);\n"
"else f2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\n"
"float f1 = 2.0 * hsl.z - f2;\n"
"rgb.r = hue_to_rgb(f1, f2, hsl.x + (1.0/3.0));\n"
"rgb.g = hue_to_rgb(f1, f2, hsl.x);\n"
"rgb.b = hue_to_rgb(f1, f2, hsl.x - (1.0/3.0));\n"
"}\n"
"return rgb;\n"
"}\n"
"void main(void)\n"
"{\n"
"vec3 col = texture2DRect(Texture0, gl_TexCoord[0].xy).rgb;\n"
"vec3 hsl = rgb_to_hsl( col );\n"
"vec3 rgb_dark = hsl_to_rgb( hsl + Local0.xyz );\n"
"vec3 rgb_mid = hsl_to_rgb( hsl + Local1.xyz );\n"
"vec3 rgb_light = hsl_to_rgb( hsl + Local2.xyz );\n"
"if( col.r > Local3.y ) gl_FragColor.r = rgb_light.r;\n" // light
"if( col.g > Local3.y ) gl_FragColor.g = rgb_light.g;\n"
"if( col.b > Local3.y ) gl_FragColor.b = rgb_light.b;\n"
"if( col.r >= Local3.x && col.r <= Local3.y ) gl_FragColor.r = rgb_mid.r;\n" // mid
"if( col.g >= Local3.x && col.g <= Local3.y ) gl_FragColor.g = rgb_mid.g;\n"
"if( col.b >= Local3.x && col.b <= Local3.y ) gl_FragColor.b = rgb_mid.b;\n"
"if( col.r < Local3.x ) gl_FragColor.r = rgb_dark.r;\n" // dark
"if( col.g < Local3.x ) gl_FragColor.g = rgb_dark.g;\n"
"if( col.b < Local3.x ) gl_FragColor.b = rgb_dark.b;\n"
"gl_FragColor.a	= 1.0;\n"
"}\n";*/

static const char g_szVertexShader_SSAORender[] = 
"uniform vec4 Local0;\n"
"void main(void)\n"
"{\n"
"gl_TexCoord[0] = gl_MultiTexCoord0.xyxy * vec4( 1.0, 1.0, 1.0 / Local0.z, 1.0 / Local0.w );\n"
"gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"}\n";

static const char g_szFragmentShader_SSAORender[] = 
"#extension GL_ARB_texture_rectangle : enable\n"
"uniform vec4 Local0;\n"
"uniform vec4 Local1;\n"
"uniform sampler2DRect Texture0;\n"
"float read_depth( vec2 coord )\n"
"{\n"
"return Local0.x / (Local0.y + Local0.x - texture2DRect( Texture0, coord ).r * Local0.y);\n"
"}\n"
"vec2 rand( vec2 coord )\n"
"{\n"
"float coordDot = dot( coord, vec2( 12.9898, 78.233 ) );\n"
"float noiseX = fract( sin( coordDot ) * 43758.5453 );\n"
"float noiseY = fract( sin( coordDot * 2.0 ) * 43758.5453 );\n"
"return vec2( noiseX, noiseY ) * 0.004;\n"
"}\n"
"float compare_depth( float depth1, float depth2 )\n"
"{\n"
"float aoRange = 60.0;\n"
"float depthDiff = depth1 - depth2;\n"
"float propagation = depthDiff * (Local0.y - Local0.x);\n"
"float rangeDiff = sqrt(clamp( 1.0 - propagation / aoRange, 0.0, 1.0 ));\n"
"float ao = Local1.z * depthDiff * (2.0 - depthDiff) * rangeDiff;\n"
"return ao;\n"
"}\n"
"void main(void)\n"
"{\n"
"float depth = read_depth( gl_TexCoord[0].xy );\n"
"float ao;\n"
"if ( depth > Local1.x && depth < Local1.y ) {\n"
"vec2 noise = rand( gl_TexCoord[0].zw );\n"
"float distScale = 1.0 + 5.0 * sqrt( 1.0 - depth );\n"
"float w = distScale + (noise.x*(1.0-noise.x)) * Local0.z;\n"
"float h = distScale + (noise.y*(1.0-noise.y)) * Local0.w;\n"
"vec2 ofs;\n"
"float d;\n"
"int samples = 3;\n"
"int rings = 3;\n"
"float TWO_PI = 2.0 * 3.14159265;\n"
"for ( int i = 1 ; i <= rings; i++ ) {\n"
"float angleStep = TWO_PI / float( samples * i );\n"
"for ( int j = 1 ; j <= samples*i; j++ ) {\n"
"ofs.x = cos( float(j) * angleStep ) * float(i) * w;\n"
"ofs.y = sin( float(j) * angleStep ) * float(i) * h;\n"
"d = read_depth( gl_TexCoord[0].xy + ofs );\n"
"// ignore occluder with too low depth value (possible viewmodel)\n"
"if ( d < Local1.x ) continue;\n"
"ao += compare_depth( depth, d );\n"
"}\n"
"}\n"
"ao = 1.0 - ao;\n"
"} else {\n"
"ao = 1.0;\n"
"}\n"
"gl_FragColor.rgb = vec3( ao );\n"
"gl_FragColor.a	= 1.0;\n"
"}\n";

static const char g_szVertexShader_SSAOBlur[] = 
"uniform vec4 Local0;\n"
"void main(void)\n"
"{\n"
"gl_TexCoord[0] = gl_MultiTexCoord0 + Local0;\n"
"gl_TexCoord[1] = gl_MultiTexCoord0 + Local0 * 2.0;\n"
"gl_TexCoord[2] = gl_MultiTexCoord0 - Local0;\n"
"gl_TexCoord[3] = gl_MultiTexCoord0 - Local0 * 2.0;\n"
"gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"}\n";

static const char g_szFragmentShader_SSAOBlur[] = 
"#extension GL_ARB_texture_rectangle : enable\n"
"uniform sampler2DRect Texture0;\n"
"void main(void)\n"
"{\n"
"vec3 col1 = texture2DRect(Texture0, gl_TexCoord[0].xy).rgb;\n"
"vec3 col2 = texture2DRect(Texture0, gl_TexCoord[1].xy).rgb;\n"
"vec3 col3 = texture2DRect(Texture0, gl_TexCoord[2].xy).rgb;\n"
"vec3 col4 = texture2DRect(Texture0, gl_TexCoord[3].xy).rgb;\n"
"gl_FragColor.rgb = (col1 + col2 + col3 + col4) / 4.0;\n"
"gl_FragColor.a	= 1.0;\n"
"}\n";

static const char g_szVertexShader_SSAOCombine[] = 
"void main(void)\n"
"{\n"
"gl_TexCoord[0] = gl_MultiTexCoord0;\n"
"gl_TexCoord[1] = gl_MultiTexCoord0 * 0.5;\n"
"gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"}\n";

static const char g_szFragmentShader_SSAOCombine[] =
"#extension GL_ARB_texture_rectangle : enable\n"
"uniform sampler2DRect Texture0;\n"
"uniform sampler2DRect Texture1;\n"
"void main(void)\n"
"{\n"
"vec3 col1 = texture2DRect(Texture0, gl_TexCoord[0].xy).rgb;\n"
"vec3 col2 = texture2DRect(Texture1, gl_TexCoord[1].xy).rgb;\n"
"float luminance = dot( col1, vec3( 0.6, 0.2, 0.2 ) );\n"
"gl_FragColor.rgb = mix( col1 * col2, col1, luminance * luminance );\n"
"gl_FragColor.a	= 1.0;\n"
"}\n";

/*static const char g_szVertexShader_BloomDarken[] =
"void main(void)\n"
"{\n"
"gl_TexCoord[0] = gl_MultiTexCoord0;\n"
"gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"}\n";

static const char g_szFragmentShader_BloomDarken[] =
"#ifdef GL_ES\n"
"precision highp float;\n"
"#endif\n"
"struct LightSource\n"
"{\n"
"int Type;\n"
"vec3 Position;\n"
"vec3 Attenuation;\n"
"vec3 Direction;\n"
"vec3 Colour;\n"
"float OuterCutoff;\n"
"float InnerCutoff;\n"
"float Exponent;\n"
"};\n"
"struct MaterialSource\n"
"{\n"
"vec3 Ambient;\n"
"vec4 Diffuse;\n"
"vec3 Specular;\n"
"float Shininess;\n"
"vec2 TextureOffset;\n"
"vec2 TextureScale;\n"
"};\n"
"uniform int NumLight;\n"
"uniform LightSource Light[4];\n"
"uniform MaterialSource Material;\n"
"varying vec4 vWorldVertex;\n"
"varying vec3 vWorldNormal;\n"
"varying vec2 vUv;\n"
"varying vec3 vViewVec;\n"
"void main ()\n"
"{\n"
"vec3 normal = normalize(vWorldNormal);\n"
"vec3 colour = Material.Ambient;\n"
"for (int i = 0; i < 4; ++i)\n"
"{\n"
"if ( i >= NumLight )\n"
"break;\n"
"vec3 lightVec = normalize(Light[i].Position - vWorldVertex.xyz);\n"
"float l = dot(normal, lightVec);\n"
"if ( l > 0.0 )\n"
"{\n"
"float spotlight = 1.0;\n"
"if ( Light[i].Type == 1 )\n"
"{\n"
"spotlight = max(-dot(lightVec, Light[i].Direction), 0.0);\n"
"float spotlightFade = clamp((Light[i].OuterCutoff - spotlight) / (Light[i].OuterCutoff - Light[i].InnerCutoff), 0.0, 1.0);\n"
"spotlight = pow(spotlight * spotlightFade, Light[i].Exponent);\n"
"}\n"
"vec3 r = -normalize(reflect(lightVec, normal));\n"
"float s = pow(max(dot(r, vViewVec), 0.0), Material.Shininess);\n"
"float d = distance(vWorldVertex.xyz, Light[i].Position);\n"
"float a = 1.0 / (Light[i].Attenuation.x + (Light[i].Attenuation.y * d) + (Light[i].Attenuation.z * d * d));\n"
"colour += ((Material.Diffuse.xyz * l) + (Material.Specular * s)) * Light[i].Colour * a * spotlight;\n"
"}\n"
"}\n"
"gl_FragColor = clamp(vec4(colour, Material.Diffuse.w), 0.0, 1.0);"
"}\n";

static const char g_szVertexShader_BloomBlur[] =
"void main(void)\n"
"{\n"
"gl_TexCoord[0] = gl_MultiTexCoord0;\n"
"gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"}\n";

static const char g_szFragmentShader_BloomBlur[] =
"#extension GL_ARB_texture_rectangle : enable\n"
"#ifdef GL_ES\n"
"precision highp float;\n"
"#endif\n"
"uniform vec4 Local0;\n"
"uniform vec2 TexelSize;\n"
"uniform sampler2DRect Sample0;\n"
"float Gaussian (float x, float deviation)\n"
"{\n"
"return (1.0 / sqrt(2.0 * 3.141592 * deviation)) * exp(-((x * x) / (2.0 * deviation)));\n"
"}\n"
"void main(void)\n"
"{\n"
"float halfBlur = float(Local0.y) * 0.5;\n"
"vec4 colour = vec4(0.0);\n"
"vec4 texColour = vec4(0.0);\n"
"float deviation = halfBlur * 0.35;\n"
"deviation *= deviation;\n"
"float strength = 1.0 - Local0[3];\n"
"if ( Local0.x == 0 )\n"
"{\n"
"for (int i = 0; i < 10; ++i)\n"
"{\n"
"if ( i >= Local0.y )\n"
"break;\n"
"float offset = float(i) - halfBlur;\n"
"texColour = texture2DRect(Sample0, gl_TexCoord[0].xy + vec2(offset * TexelSize.x * Local0.z, 0.0)) * Gaussian(offset * strength, deviation);\n"
"colour += texColour;\n"
"}\n"
"}\n"
"else\n"
"{\n"
"for (int i = 0; i < 10; ++i)\n"
"{\n"
"if ( i >= Local0.y )\n"
"break;\n"
"float offset = float(i) - halfBlur;\n"
"texColour = texture2DRect(Sample0, gl_TexCoord[0].xy + vec2(0.0, offset * TexelSize.y * Local0.z)) * Gaussian(offset * strength, deviation);\n"
"colour += texColour;\n"
"}\n"
"}\n"
"gl_FragColor = clamp(colour, 0.0, 1.0);\n"
"gl_FragColor.w = 1.0;\n"
"}\n";

static const char g_szVertexShader_BloomCombine[] =
"void main(void)\n"
"{\n"
"gl_TexCoord[0] = gl_MultiTexCoord0;\n"
"gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"}\n";

static const char g_szFragmentShader_BloomCombine[] =
"#extension GL_ARB_texture_rectangle : enable\n"
"#ifdef GL_ES\n"
"precision highp float;\n"
"#endif\n"
"uniform vec4 Local0;\n"
"uniform sampler2DRect Sample0;\n"
"uniform sampler2DRect Sample1;\n"
"void main ()\n"
"{\n"
"vec4 dst = texture2DRect(Sample0, gl_TexCoord[0].xy);\n"
"vec4 src = texture2DRect(Sample1, gl_TexCoord[0].xy);\n"
"if ( Local0.x == 0 )\n"
"{\n"
"gl_FragColor = min(src + dst, 1.0);\n"
"}\n"
"else if ( Local0.x == 1 )\n"
"{\n"
"gl_FragColor = clamp((src + dst) - (src * dst), 0.0, 1.0);\n"
"gl_FragColor.w = 1.0;\n"
"}\n"
"else\n"
"{\n"
"gl_FragColor = src;\n"
"}\n"
"}\n";*/

static const char g_szVertexShader_BloomDarken[] =
"void main(void)\n"
"{\n"
"gl_TexCoord[0] = gl_MultiTexCoord0;\n"
"gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"}\n";

static const char g_szFragmentShader_BloomDarken[] =
"#version 130\n"
"#extension GL_ARB_texture_rectangle : enable\n"
"precision lowp float;\n"
"uniform vec4 Local0;\n"
"uniform sampler2DRect Texture0;\n"
"void main(void)\n"
"{\n"
"vec3 col = texture2DRect(Texture0, gl_TexCoord[0].xy).rgb;\n"
"gl_FragColor.rgb = pow( col, Local0.xxx );\n"
"gl_FragColor.a	= 1.0;\n"
"}\n";

#if 0
static const char g_szVertexShader_BloomBlur[] =
"void main(void)\n"
"{\n"
"gl_TexCoord[0] = gl_MultiTexCoord0;\n"
"gl_Position = ftransform();\n"
"}\n";

static const char g_szFragmentShader_BloomBlur[] =
"#extension GL_ARB_texture_rectangle : enable\n"
"uniform vec4 Local0;\n"
"uniform sampler2DRect source;\n"
"void main(void) {\n"
"vec2 tc = gl_TexCoord[0].st;\n"
"gl_FragColor = 0.0285367 * texture2DRect(source, tc);\n"
"for( int i = 0; i < 16; i += 2 ) {\n"
"gl_FragColor += ( 0.0567264 / (i/16+1) ) *\n"
"(texture2DRect(source, tc - (Local0.xy * ( 1.49817 + i ) )) +\n"
"texture2DRect(source, tc + (Local0.xy * ( 1.49817 + i ) )));\n"
"}\n"
/*"gl_FragColor += 0.0553599 *\n"
"(texture2DRect(source, tc - (Local0.xy * 3.49573)) +\n"
"texture2DRect(source, tc + (Local0.xy * 3.49573)));\n"
"gl_FragColor += 0.0529827 *\n"
"(texture2DRect(source, tc - (Local0.xy * 5.49329)) +\n"
"texture2DRect(source, tc + (Local0.xy * 5.49329)));\n"
"gl_FragColor += 0.0497279 *\n"
"(texture2DRect(source, tc - (Local0.xy * 7.49085)) +\n"
"texture2DRect(source, tc + (Local0.xy * 7.49085)));\n"
"gl_FragColor += 0.0457714 *\n"
"(texture2DRect(source, tc - (Local0.xy * 9.48841)) +\n"
"texture2DRect(source, tc + (Local0.xy * 9.48841)));\n"
"gl_FragColor += 0.0413158 *\n"
"(texture2DRect(source, tc - (Local0.xy * 11.486)) +\n"
"texture2DRect(source, tc + (Local0.xy * 11.486)));\n"
"gl_FragColor += 0.0365735 *\n"
"(texture2DRect(source, tc - (Local0.xy * 13.4835)) +\n"
"texture2DRect(source, tc + (Local0.xy * 13.4835)));\n"
"gl_FragColor += 0.0317501 *\n"
"(texture2DRect(source, tc - (Local0.xy * 15.4811)) +\n"
"texture2DRect(source, tc + (Local0.xy * 15.4811)));\n"
"gl_FragColor += 0.0270303 *\n"
"(texture2DRect(source, tc - (Local0.xy * 17.4787)) +\n"
"texture2DRect(source, tc + (Local0.xy * 17.4787)));\n"
"gl_FragColor += 0.0225676 *\n"
"(texture2DRect(source, tc - (Local0.xy * 19.4762)) +\n"
"texture2DRect(source, tc + (Local0.xy * 19.4762)));\n"
"gl_FragColor += 0.0184777 *\n"
"(texture2DRect(source, tc - (Local0.xy * 21.4738)) +\n"
"texture2DRect(source, tc + (Local0.xy * 21.4738)));\n"
"gl_FragColor += 0.0148367 *\n"
"(texture2DRect(source, tc - (Local0.xy * 23.4713)) +\n"
"texture2DRect(source, tc + (Local0.xy * 23.4713)));\n"
"gl_FragColor += 0.0116831 *\n"
"(texture2DRect(source, tc - (Local0.xy * 25.4689)) +\n"
"texture2DRect(source, tc + (Local0.xy * 25.4689)));\n"
"gl_FragColor += 0.00902199 *\n"
"(texture2DRect(source, tc - (Local0.xy * 27.4665)) +\n"
"texture2DRect(source, tc + (Local0.xy * 27.4665)));\n"
"gl_FragColor += 0.00683246 *\n"
"(texture2DRect(source, tc - (Local0.xy * 29.4641)) +\n"
"texture2DRect(source, tc + (Local0.xy * 29.4641)));\n"
"gl_FragColor += 0.00507434 *\n"
"(texture2DRect(source, tc - (Local0.xy * 31.4616)) +\n"
"texture2DRect(source, tc + (Local0.xy * 31.4616)));\n"*/
"}\n";

#endif

static const char g_szVertexShader_BloomBlur[] =
"#version 130\n"
"#extension GL_ARB_texture_rectangle : enable\n"
"precision lowp float;\n"
"uniform vec4 Local0;\n"
"varying vec4 texCoord[16];\n"
"void main(void)\n"
"{\n"
"texCoord[0] = gl_MultiTexCoord0 + Local0;\n"
"texCoord[1] = gl_MultiTexCoord0 + Local0 * 1.50;\n"
"texCoord[2] = gl_MultiTexCoord0 + Local0 * 1.75;\n"
"texCoord[3] = gl_MultiTexCoord0 + Local0 * 2.00;\n"
"texCoord[4] = gl_MultiTexCoord0 - Local0;\n"
"texCoord[5] = gl_MultiTexCoord0 - Local0 * 1.50;\n"
"texCoord[6] = gl_MultiTexCoord0 - Local0 * 1.75;\n"
"texCoord[7] = gl_MultiTexCoord0 - Local0 * 2.00;\n"
"gl_Position = ftransform();\n"
"}\n";

static const char g_szFragmentShader_BloomBlur[] =
"#version 130\n"
"#extension GL_ARB_texture_rectangle : enable\n"
"precision lowp float;\n"
"uniform sampler2DRect Texture0;\n"
"varying vec4 texCoord[16];\n"
"void main(void)\n"
"{\n"
"vec3 col1 = texture2DRect(Texture0, texCoord[0].xy).rgb;\n"
"vec3 col2 = texture2DRect(Texture0, texCoord[1].xy).rgb;\n"
"vec3 col3 = texture2DRect(Texture0, texCoord[2].xy).rgb;\n"
"vec3 col4 = texture2DRect(Texture0, texCoord[3].xy).rgb;\n"
"vec3 col5 = texture2DRect(Texture0, texCoord[4].xy).rgb;\n"
"vec3 col6 = texture2DRect(Texture0, texCoord[5].xy).rgb;\n"
"vec3 col7 = texture2DRect(Texture0, texCoord[6].xy).rgb;\n"
"vec3 col8 = texture2DRect(Texture0, texCoord[7].xy).rgb;\n"
"gl_FragColor.rgb = (col1 + col2 + col3 + col4 + col5 + col6 + col7 + col8) / 8.0;\n"
"gl_FragColor.a	= 1.0;\n"
"}\n";

/*static const char g_szVertexShader_BloomBlur[] =
"#extension GL_ARB_texture_rectangle : enable\n"
"uniform vec4 Local0;\n"
"uniform vec4 Local1;\n"
"varying vec2 texCoord[31];\n"
"void main(void)\n"
"{\n"
"int i;\n"
"int j = 0;\n"
"int numSamples = int( Local1.x );\n"
"int numSamples_mid = int( Local1.x / 2 );\n"
"float inc = 2.0 / Local1.x;\n"
"for( i = 0; i < numSamples_mid; i++ ) {\n"
"if( j == 1 ) { j++; }\n"
"texCoord[i] = ( gl_MultiTexCoord0 + Local0 * ( inc * float( j ) + 1.0 ) ).xy;\n"
"j++;\n"
"}\n"
"j = 0;\n"
"for( i = numSamples_mid; i < numSamples; i++ ) {\n"
"if( j == 1 ) { j++; }\n"
"texCoord[i] = ( gl_MultiTexCoord0 - Local0 * ( inc * float( j ) + 1.0 ) ).xy;\n"
"j++;\n"
"}\n"
"gl_Position = ftransform();\n"
"}\n";

static const char g_szFragmentShader_BloomBlur[] =
"#extension GL_ARB_texture_rectangle : enable\n"
"precision lowp float;\n"
"uniform sampler2DRect Texture0;\n"
"uniform vec4 Local1;\n"
"varying vec4 texCoord[31];\n"
"void main(void)\n"
"{\n"
"int numSamples = int( Local1.x );\n"
"gl_FragColor = vec4( 0.0 );\n"
"for( int i = 0; i < numSamples; i++ ) {\n"
"gl_FragColor += texture2DRect( Texture0, texCoord[i] );\n"
"}\n"
"gl_FragColor.rgb /= Local1.x;\n"
"gl_FragColor.a = 1.0;\n"
"}\n";*/

static const char g_szVertexShader_BloomCombine[] =
"void main(void)\n"
"{\n"
"gl_TexCoord[0] = gl_MultiTexCoord0;\n"
"gl_TexCoord[1] = gl_MultiTexCoord0 * 0.5;\n"
"gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"}\n";

static const char g_szFragmentShader_BloomCombine[] =
"#version 130\n"
"#extension GL_ARB_texture_rectangle : enable\n"
"precision lowp float;\n"
"uniform vec4 Local0;\n"
"uniform sampler2DRect Texture0;\n"
"uniform sampler2DRect Texture1;\n"
"void main(void)\n"
"{\n"
"vec3 col1 = texture2DRect(Texture0, gl_TexCoord[0].xy).rgb;\n"
"vec3 col2 = texture2DRect(Texture1, gl_TexCoord[1].xy).rgb;\n"
"gl_FragColor.rgb = col1 + ( col2 * Local0.xxx + col2 * Local0.yyy );\n"
"gl_FragColor.a	= 1.0;\n"
"}\n";

static const char g_szVertexShader_BrightnessContrast[] =
"void main(void)\n"
"{\n"
"gl_TexCoord[0] = gl_MultiTexCoord0;\n"
"gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"}\n";

static const char g_szFragmentShader_BrightnessContrast[] =
"#version 130\n"
"#extension GL_ARB_texture_rectangle : enable\n"
"precision lowp float;\n"
"uniform sampler2DRect Texture0;\n"
"uniform vec4 Local0;\n"
"uniform vec4 Local3;\n"
"void main(void)\n"
"{\n"
"vec4 col = texture2DRect( Texture0, gl_TexCoord[0].xy );\n"
"vec4 AverageLuminance;\n"
"AverageLuminance = vec4( 0.5, 0.5, 0.5, 1.0 );"
"float Contrast = Local0.a - 1;\n"
"if( Contrast < 0.0 ) Contrast = 0.0;\n"
"vec3 bright = Local0.xyz;\n"
"vec4 luminance = mix( col * vec4( Local0.x+1.0, Local0.y+1.0, Local0.z+1.0, 1.0 ), mix( AverageLuminance, col, Local0.a ), 0.5 );\n"
"if( col.r >= Local3.x && col.r <= Local3.y ) { gl_FragColor.r = luminance.r; } else if( col.r < Local3.x ) { gl_FragColor.r = luminance.r; } else if( col.r > Local3.y ) { gl_FragColor.r = luminance.r; }\n"
"if( col.g >= Local3.x && col.g <= Local3.y ) { gl_FragColor.g = luminance.g; } else if( col.g < Local3.x ) { gl_FragColor.g = luminance.g; } else if( col.g > Local3.y ) { gl_FragColor.g = luminance.g; }\n"
"if( col.b >= Local3.x && col.b <= Local3.y ) { gl_FragColor.b = luminance.b; } else if( col.b < Local3.x ) { gl_FragColor.b = luminance.b; } else if( col.b > Local3.y ) { gl_FragColor.b = luminance.b; }\n"
"gl_FragColor.rgb += bright;\n"
"}\n";

static const char g_szVertexShader_Tint[] =
"void main(void)\n"
"{\n"
"gl_TexCoord[0] = gl_MultiTexCoord0;\n"
"gl_Position = ftransform();\n"
"}\n";

static const char g_szFragmentShader_Tint[] =
"#extension GL_ARB_texture_rectangle : enable\n"
"uniform vec4 Local0;\n"
"uniform vec4 Local1;\n"
"uniform vec4 Local2;\n"
"uniform vec4 Local3;\n"
"uniform vec4 Local4;\n"
"uniform vec4 Local5;\n"
"uniform sampler2DRect Texture0;\n"
"void main(void)\n"
"{\n"
"vec4 col = texture2DRect(Texture0, gl_TexCoord[0].xy);\n"
"vec4 AverageLuminance;\n"
"AverageLuminance = vec4( 0.5, 0.5, 0.5, 1.0 );"
"float Contrast = Local4.a - 1.0;\n"
"if( Contrast < 0.0 ) Contrast = 0.0;\n"
"vec3 bright = Local4.xyz;\n"
"vec4 luminance = mix( col * vec4( Local4.x+1.0, Local4.y+1.0, Local4.z+1.0, 1.0 ), mix( AverageLuminance, col, Local4.a ), 0.5 );\n"
"if( col.r >= Local3.x && col.r <= Local3.y ) { gl_FragColor.r = luminance.r * Local1.r; } else if( col.r < Local3.x ) { gl_FragColor.r = luminance.r * Local2.r; } else if( col.r > Local3.y ) { gl_FragColor.r = luminance.r * Local0.r; }\n"
"if( col.g >= Local3.x && col.g <= Local3.y ) { gl_FragColor.g = luminance.g * Local1.g; } else if( col.g < Local3.x ) { gl_FragColor.g = luminance.g * Local2.g; } else if( col.g > Local3.y ) { gl_FragColor.g = luminance.g * Local0.g; }\n"
"if( col.b >= Local3.x && col.b <= Local3.y ) { gl_FragColor.b = luminance.b * Local1.b; } else if( col.b < Local3.x ) { gl_FragColor.b = luminance.b * Local2.b; } else if( col.b > Local3.y ) { gl_FragColor.b = luminance.b * Local0.b; }\n"
"gl_FragColor.rgb += bright;\n"
"gl_FragColor.rgb *= Local5.xxx;\n"
"}\n";

static const char g_szVertexShader_Bleach[] =
"void main(void)\n"
"{\n"
"gl_TexCoord[0] = gl_MultiTexCoord0;\n"
"gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"}\n";

static const char g_szFragmentShader_Bleach[] =
"#version 130\n"
"#extension GL_ARB_texture_rectangle : enable\n"
"precision lowp float;\n"
"uniform vec4 Local0;\n"
"uniform vec4 Local3;\n"
"uniform sampler2DRect Texture0;\n"
"void main(void)\n"
"{\n"
"vec3 col = texture2DRect(Texture0, gl_TexCoord[0].xy).rgb;\n"
/*"if( Local1.x < col.r ) if( Local0.z > col.r ) { gl_FragColor.r = Local0.z - col.r; } else { gl_FragColor.r = col.r - Local0.z; }\n"
"if( Local1.x < col.g ) if( Local0.z > col.g ) { gl_FragColor.g = Local0.z - col.g; } else { gl_FragColor.g = col.g - Local0.z; }\n"
"if( Local1.x < col.b ) if( Local0.z > col.b ) { gl_FragColor.b = Local0.z - col.b; } else { gl_FragColor.b = col.b - Local0.z; }\n"
"if( Local1.x >= col.r && Local1.y <= col.r ) if( Local0.y > col.r ) { gl_FragColor.r = Local0.y - col.r; } else { gl_FragColor.r = col.r - Local0.y; }\n"
"if( Local1.x >= col.g && Local1.y <= col.g ) if( Local0.y > col.g ) { gl_FragColor.g = Local0.y - col.g; } else { gl_FragColor.g = col.g - Local0.y; }\n"
"if( Local1.x >= col.b && Local1.y <= col.b ) if( Local0.y > col.b ) { gl_FragColor.b = Local0.y - col.b; } else { gl_FragColor.b = col.b - Local0.y; }\n"
"if( Local1.y > col.r ) if( Local0.x > col.r ) { gl_FragColor.r = Local0.x - col.r; } else { gl_FragColor.r = col.r - Local0.x; }\n"
"if( Local1.y > col.g ) if( Local0.x > col.g ) { gl_FragColor.g = Local0.x - col.g; } else { gl_FragColor.g = col.g - Local0.x; }\n"
"if( Local1.y > col.b ) if( Local0.x > col.b ) { gl_FragColor.b = Local0.x - col.b; } else { gl_FragColor.b = col.b - Local0.x; }\n"*/
"if( Local3.x < col.r ) { gl_FragColor.r = pow( col.r, 1.0 - Local0.z ); }\n"
"if( Local3.x < col.g ) { gl_FragColor.g = pow( col.g, 1.0 - Local0.z ); }\n"
"if( Local3.x < col.b ) { gl_FragColor.b = pow( col.b, 1.0 - Local0.z ); }\n"
"if( Local3.x >= col.r && Local3.y <= col.r ) { gl_FragColor.r = pow( col.r, 1.0 - Local0.y ); }\n"
"if( Local3.x >= col.g && Local3.y <= col.g ) { gl_FragColor.g = pow( col.g, 1.0 - Local0.y ); }\n"
"if( Local3.x >= col.b && Local3.y <= col.b ) { gl_FragColor.b = pow( col.b, 1.0 - Local0.y ); }\n"
"if( Local3.y > col.r ) { gl_FragColor.r = pow( col.r, 1.0 - Local0.x ); }\n"
"if( Local3.y > col.g ) { gl_FragColor.g = pow( col.g, 1.0 - Local0.x ); }\n"
"if( Local3.y > col.b ) { gl_FragColor.b = pow( col.b, 1.0 - Local0.x ); }\n"
"}\n";

/*static const char g_szVertexShader_Invert[] =
"void main(void)\n"
"{\n"
"gl_TexCoord[0] = gl_MultiTexCoord0;\n"
"gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"}\n";

static const char g_szFragmentShader_Invert[] =
"precision lowp float;\n"
"uniform vec4 Local0;\n"
"uniform sampler2DRect Texture0;\n"
"void main(void)\n"
"{\n"
"vec3 col = texture2DRect(Texture0, gl_TexCoord[0].xy).rgb;\n"
"gl_FragColor.rgb = 1 * Local0.x - col;\n"
"if( gl_FragColor.r < 0 ) gl_FragColor.r = -gl_FragColor.r;\n"
"if( gl_FragColor.g < 0 ) gl_FragColor.g = -gl_FragColor.g;\n"
"if( gl_FragColor.b < 0 ) gl_FragColor.b = -gl_FragColor.b;\n"
"gl_FragColor.a	= 1.0;\n"
"}\n";*/

static const char g_szVertexShader_MotionBlur[] =
"void main(void)\n"
"{\n"
"gl_TexCoord[0] = gl_MultiTexCoord0;\n"
"gl_Position = ftransform();\n"
"}\n";

// https://subversion.assembla.com/svn/efekt/trunk/Src/shaders/blur_fs.glsl

static const char g_szFragmentShader_MotionBlur[] =
"#version 150\n"
"uniform sampler2DArray tex;\n"
"uniform sampler2DArrayShadow depthTex;\n"
"uniform mat4 g_ViewProjectionInverseMatrix;\n"
"uniform mat4 g_previousViewProjectionMatrix;\n"
"uniform int SAMPLES;\n"
"in vec2 inoutTexCoord;\n"
"out vec4 outColor;\n"
"void main(void) {\n"
"outColor = vec4( 0.0 );"
"int SAMPLES2 = 40;\n"
"float zOverW = texture( depthTex, vec4( inoutTexCoord, 0, 0));\n"
"vec4 H = vec4(2*inoutTexCoord.x - 1.0f, 2*inoutTexCoord.y - 1.0f, 2*zOverW-1.0f, 1);\n"
"vec4 D = g_ViewProjectionInverseMatrix * H;\n"
"vec4 worldPos = D / D.w;\n"
"vec4 currentPos = H;\n"
"vec4 previousPos = g_previousViewProjectionMatrix * worldPos;\n"
"previousPos /= previousPos.w;\n"
"vec2 velocity = (currentPos - previousPos).xy/(SAMPLES2);\n"
"vec4 color = vec4(0);\n"
"vec2 texCoord = inoutTexCoord;\n"
"for(int i = 0; i < SAMPLES2; ++i, texCoord += velocity) {\n"
"color += texture( tex, vec3( clamp(texCoord,0.0,1.0), 0 ) );\n"
"}\n"
"outColor = color;\n"
"outColor /= outColor.a;"
"}\n";

static const char g_szVertexShader_Shadow[] =
"#version 330 core\n"
"layout(location = 0) in vec3 vertexPosition_modelspace;\n"
"uniform mat4 depthMVP;\n"
"void main() {\n"
"gl_Position =  depthMVP * vec4(vertexPosition_modelspace,1);\n"
"}\n";

static const char g_szFragmentShader_Shadow[] =
"#version 330 core\n"
"layout(location = 0) out float fragmentdepth;\n"
"void main() {\n"
"fragmentdepth = gl_FragCoord.z;\n"
"}\n";

static const char g_szVertexShader_LightReflection[] =
"void main(void)\n"
"{\n"
"gl_TexCoord[0] = gl_MultiTexCoord0;\n"
"gl_Position = ftransform();\n"
"}\n";

static const char g_szFragmentShader_LightReflection[] =
"#version 150\n"
"#extension GL_ARB_texture_rectangle : enable\n"
"uniform mat4 model;\n"
"uniform vec3 cameraPosition;\n"
"uniform sampler2D materialTex;\n"
"uniform float materialShininess;\n"
"uniform vec3 materialSpecularColor;\n"
"uniform struct Light {\n"
"vec3 position;\n"
"vec3 intensities;\n"
"float attenuation;\n"
"float ambientCoefficient;\n"
"} light;\n"
"in vec2 fragTexCoord;\n"
"in vec3 fragNormal;\n"
"in vec3 fragVert;\n"
"out vec4 finalColor;\n"
"void main() {\n"
"vec3 normal = normalize(transpose(inverse(mat3(model))) * fragNormal);\n"
"vec3 surfacePos = vec3(model * vec4(fragVert, 1));\n"
"vec4 surfaceColor = texture(materialTex, fragTexCoord);\n"
"vec3 surfaceToLight = normalize(light.position - surfacePos);\n"
"vec3 surfaceToCamera = normalize(cameraPosition - surfacePos);\n"
"vec3 ambient = light.ambientCoefficient * surfaceColor.rgb * light.intensities;\n"
"float diffuseCoefficient = max(0.0, dot(normal, surfaceToLight));\n"
"vec3 diffuse = diffuseCoefficient * surfaceColor.rgb * light.intensities;\n"
"float specularCoefficient = 0.0;\n"
"if(diffuseCoefficient > 0.0)\n"
"specularCoefficient = pow(max(0.0, dot(surfaceToCamera, reflect(-surfaceToLight, normal))), materialShininess);\n"
"vec3 specular = specularCoefficient * materialSpecularColor * light.intensities;\n"
"float distanceToLight = length(light.position - surfacePos);\n"
"float attenuation = 1.0 / (1.0 + light.attenuation * pow(distanceToLight, 2));\n"
"vec3 linearColor = ambient + attenuation*(diffuse + specular);\n"
"vec3 gamma = vec3(1.0/2.2);\n"
"finalColor = vec4(pow(linearColor, gamma), surfaceColor.a);\n"
"}\n";

// see http://www.geeks3d.com/20140213/glsl-shader-library-fish-eye-and-dome-and-barrel-distortion-post-processing-filters/2/ for distortion shaders

static const char g_szVertexShader_Distortion[] =
"varying vec4 uv;\n"
"void main()\n"
"{\n"
"gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"uv = gl_MultiTexCoord0;\n"
"}\n";

static const char g_szFragmentShader_Distortion[] =
"#extension GL_ARB_texture_rectangle : enable\n"
"varying vec4 uv;\n"
"uniform sampler2DRect Texture0;\n"
"uniform vec4 Local0;\n"
"void main()\n"
"{\n"
"vec2 textureCoordinateToUse = uv.xy;\n"
"vec2 center = Local0.xy;\n"
"float radius = Local0.z;\n"
"float scale = Local0.w / 10000.0;\n"
"float dist = distance( center, uv.xy );\n"
"textureCoordinateToUse -= center;\n"
"float percent = radius + ( ( 0.5 - dist ) / 0.5 ) * scale;\n"
"textureCoordinateToUse = textureCoordinateToUse * percent;\n"
"textureCoordinateToUse += center;\n"
"gl_FragColor = texture2DRect( Texture0, textureCoordinateToUse );\n"
"}\n";

// http://www.geeks3d.com/20100909/shader-library-gaussian-blur-post-processing-filter-in-glsl/

static const char g_szVertexShader_Blur[] =
"#extension GL_ARB_texture_rectangle : enable\n"
"void main(void)\n"
"{\n"
"gl_Position = ftransform();\n"
"gl_TexCoord[ 0 ] = gl_MultiTexCoord0;\n"
"}\n";

static const char g_szFragmentShader_Blur[] =
"#version 120\n"
"#extension GL_ARB_texture_rectangle : enable\n"
"uniform sampler2DRect Texture0;\n"
"uniform vec4 Local0;\n"
"float offset[ 5 ] = float[]( 0.0, 1.0, 2.0, 3.0, 4.0 );\n"
"float weight[ 5 ] = float[]( 0.2270270270, 0.1945945946, 0.1216216216, 0.0540540541, 0.0162162162 );\n"
"void main()\n"
"{\n"
"vec3 tc;\n"
"vec2 uv = gl_TexCoord[ 0 ].xy;\n"
"tc = texture2DRect( Texture0, uv ).rgb * weight[ 0 ];\n"
"if( Local0.y > 0.0 ) {\n"
"for( int i = 1; i < 5; i++ )\n"
"{\n"
"tc += texture2DRect( Texture0, uv + vec2( 0.0, offset[ i ] ) * Local0.y ).rgb * weight[ i ];\n"
"tc += texture2DRect( Texture0, uv - vec2( 0.0, offset[ i ] ) * Local0.y ).rgb * weight[ i ];\n"
"}\n"
"} else {\n"
"for( int i = 1; i < 5; i++ )\n"
"{\n"
"tc += texture2DRect( Texture0, uv + vec2( offset[ i ], 0.0 ) * Local0.x ).rgb * weight[ i ];\n"
"tc += texture2DRect( Texture0, uv - vec2( offset[ i ], 0.0 ) * Local0.x ).rgb * weight[ i ];\n"
"}\n"
"}\n"
"gl_FragColor = vec4( tc, 1.0 );\n"
"}\n";

static const char g_szVertexShader_FXAA[] =
"void main( void ) {\n"
"gl_Position = ftransform();\n"
"gl_TexCoord[ 0 ] = gl_MultiTexCoord0;\n"
"}\n";

static const char g_szFragmentShader_FXAA[] =
"#extension GL_ARB_texture_rectangle : enable\n"
"uniform vec4 Local0;\n"
"uniform sampler2DRect Texture0;\n"
"void main( void ) {\n"
"float FXAA_SPAN_MAX = 8.0;\n"
"float FXAA_REDUCE_MUL = 1.0 / 8.0;\n"
"float FXAA_REDUCE_MIN = 1.0 / 128.0;\n"
"vec3 rgbNW = texture2DRect( Texture0, gl_TexCoord[ 0 ].xy + ( vec2( -1.0, -1.0 ) / Local0.xy ) ).xyz;\n"
"vec3 rgbNE = texture2DRect( Texture0, gl_TexCoord[ 0 ].xy + ( vec2( 1.0, -1.0 ) / Local0.xy ) ).xyz;\n"
"vec3 rgbSW = texture2DRect( Texture0, gl_TexCoord[ 0 ].xy + ( vec2( -1.0, 1.0 ) / Local0.xy ) ).xyz;\n"
"vec3 rgbSE = texture2DRect( Texture0, gl_TexCoord[ 0 ].xy + ( vec2( 1.0, 1.0 ) / Local0.xy ) ).xyz;\n"
"vec3 rgbM = texture2DRect( Texture0, gl_TexCoord[ 0 ].xy ).xyz;\n"
"vec3 luma = vec3( 0.299, 0.587, 0.114 );\n"
"float lumaNW = dot( rgbNW, luma );\n"
"float lumaNE = dot( rgbNE, luma );\n"
"float lumaSW = dot( rgbSW, luma );\n"
"float lumaSE = dot( rgbSE, luma );\n"
"float lumaM = dot( rgbM, luma );\n"
"float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );\n"
"float lumaMax = max( lumaM, max( max( lumaNW, lumaNE ), max( lumaSW, lumaSE ) ) );\n"
"vec2 dir;\n"
"dir.x = -( ( lumaNW + lumaNE ) - ( lumaSW + lumaSE ) );\n"
"dir.y = ( ( lumaNW + lumaSW ) - ( lumaNE + lumaSE ) );\n"
"float dirReduce = max(\n"
"( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ),\n"
"FXAA_REDUCE_MIN );\n"
"float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );\n"
"dir = min( vec2( FXAA_SPAN_MAX, FXAA_SPAN_MAX ),\n"
"max( vec2( -FXAA_SPAN_MAX, -FXAA_SPAN_MAX ),\n"
"dir * rcpDirMin ) ) / Local0.xy;\n"
"vec3 rgbA = ( 1.0 / 2.0 ) * (\n"
"texture2DRect( Texture0, gl_TexCoord[ 0 ].xy + dir * ( 1.0 / 3.0 - 0.5 ) ).xyz +\n"
"texture2DRect( Texture0, gl_TexCoord[ 0 ].xy + dir * ( 2.0 / 3.0 - 0.5 ) ).xyz );\n"
"vec3 rgbB = rgbA * ( 1.0 / 2.0 ) + ( 1.0 / 4.0 ) * (\n"
"texture2DRect( Texture0, gl_TexCoord[ 0 ].xy + dir * ( 0.0 / 3.0 - 0.5 ) ).xyz +\n"
"texture2DRect( Texture0, gl_TexCoord[ 0 ].xy + dir * ( 3.0 / 3.0 - 0.5 ) ).xyz );\n"
"float lumaB = dot( rgbB, luma );\n"
"if( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ){\n"
"gl_FragColor.xyz = vec4( rgbA, 1 );\n"
"}\n"
"else{\n"
"gl_FragColor.xyz = vec4( rgbB, 1 );\n"
"}\n"
"}\n";

static const char g_szVertexShader_Displacement[] =
"void main( void ) {\n"
"gl_Position = ftransform();\n"
"gl_TexCoord[ 0 ] = gl_MultiTexCoord0;\n"
"}\n";

static const char g_szFragmentShader_Displacement[] =
"void main( void ) {\n"
"gl_FragColor = vec4( 0, 0, 0, 0 );\n"
"}\n";

static const char g_szVertexShader_ShadowMap[] =
"varying vec4 ShadowCoord;\n"
"void main() {\n"
"ShadowCoord = gl_TextureMatrix[ 7 ] * gl_Vertex;\n"
"gl_Position = ftransform();\n"
"gl_FrontColor = gl_Color;\n"
"}\n";

static const char g_szFragmentShader_ShadowMap[] =
"uniform sampler2D Texture7;\n"
"varying vec4 ShadowCoord;\n"
"void main() {\n"
"vec4 shadowCoordinateWdivide = ShadowCoord / ShadowCoord.w;\n"
"shadowCoordinateWdivide.z += 0.0005;\n"
"float distanceFromLight = texture2D( Texture7, shadowCoordinateWdivide ).z;\n"
"float shadow = 1.0;\n"
"if( ShadowCoord.w > 0.0 )\n"
"shadow = distanceFromLight < shadowCoordinateWdivide.z ? 0.5 : 1.0;\n"
"gl_FragColor = shadow * gl_Color;\n"
"}\n";

#endif //QFX_GLPROGS_H
